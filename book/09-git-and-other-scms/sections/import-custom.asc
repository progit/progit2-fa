[[_custom_importer]]
==== یک واردکننده سفارشی

(((git commands, fast-import)))
(((Importing, from others)))
اگر سیستم شما یکی از موارد بالا نیست، باید به دنبال یک واردکننده آنلاین باشید – واردکننده‌های با کیفیت برای
        بسیاری از سیستم‌های دیگر، از جمله CVS، Clear Case، Visual Source Safe، حتی یک دایرکتوری از آرشیوها در دسترس
        هستند.
        اگر هیچ‌یک از این ابزارها برای شما کار نمی‌کند، شما یک ابزار کمتر شناخته شده دارید، یا به هر دلیلی به یک فرآیند
        واردات سفارشی نیاز دارید، باید از `git fast-import` استفاده کنید.
        این دستور از stdin دستورالعمل‌های ساده‌ای می‌خواند تا داده‌های خاص گیت را بنویسد.
        این روش بسیار آسان‌تر است تا اینکه دستورات خام گیت را اجرا کنید یا سعی کنید اشیاء خام را بنویسید (برای اطلاعات
        بیشتر به <<ch10-git-internals#ch10-git-internals>> مراجعه کنید).
        به این ترتیب، می‌توانید یک اسکریپت واردات بنویسید که اطلاعات لازم را از سیستمی که از آن وارد می‌کنید بخواند و
        دستورالعمل‌های ساده‌ای را به stdout چاپ کند.
        سپس می‌توانید این برنامه را اجرا کرده و خروجی آن را از طریق `git fast-import` هدایت کنید.

برای نشان دادن سریع، شما یک واردکننده ساده خواهید نوشت.
        فرض کنید شما در `current` کار می‌کنید، پروژه خود را با کپی کردن دایرکتوری به طور دوره‌ای به یک
        دایرکتوری پشتیبان با زمان‌مهر `back_YYYY_MM_DD` پشتیبان‌گیری می‌کنید و می‌خواهید این را به گیت وارد
        کنید.
        ساختار دایرکتوری شما به این شکل است:

[source,console]
----
$ ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current
----

برای وارد کردن یک دایرکتوری گیت، شما باید بررسی کنید که گیت چگونه داده‌های خود را ذخیره می‌کند.
        همانطور که ممکن است به یاد داشته باشید، گیت اساساً یک لیست پیوندی از اشیاء کامیت است که به یک تصویر از محتوا
        اشاره می‌کند.
        تنها کاری که باید انجام دهید این است که به `fast-import` بگویید که محتوای تصاویر چیست، داده‌های کامیت
        به آن‌ها اشاره می‌کند و ترتیب آن‌ها چگونه است.
        استراتژی شما این خواهد بود که به صورت یک به یک از تصاویر عبور کنید و کامیت‌هایی با محتوای هر دایرکتوری ایجاد
        کنید و هر کامیت را به کامیت قبلی پیوند دهید.

همانطور که در <<_an_example_git_enforced_policy#_an_example_git_enforced_policy>> انجام دادیم، ما این را در Ruby خواهیم نوشت، زیرا این چیزی است که ما معمولاً با آن کار می‌کنیم و
        معمولاً خواندن آن آسان است.
        شما می‌توانید این مثال را به راحتی در هر چیزی که با آن آشنا هستید بنویسید – فقط باید اطلاعات مناسب را به `stdout`
        چاپ کند.
        و اگر شما در حال اجرای ویندوز هستید، این بدان معناست که باید مراقب باشید که در انتهای خطوط خود کاراکترهای بازگشت
        کاراکتر را معرفی نکنید – `git fast-import` بسیار خاص است که فقط می‌خواهد خط‌های جدید (LF) و نه بازگشت
        خط‌های کاراکتر (CRLF) که ویندوز استفاده می‌کند.

برای شروع، شما به دایرکتوری هدف تغییر می‌دهید و هر زیر دایرکتوری را شناسایی می‌کنید، که هر کدام یک تصویر است که
        می‌خواهید به عنوان یک کامیت وارد کنید.
        شما به هر زیر دایرکتوری تغییر می‌دهید و دستورات لازم برای صادرات آن را چاپ می‌کنید.
        حلقه اصلی شما به این شکل به نظر می‌رسد:

[source,ruby]
----
last_mark = nil

# حلقه از طریق دایرکتوری‌ها
Dir.chdir(ARGV[0]) do
  Dir.glob("*").each do |dir|
    next if File.file?(dir)

    # به دایرکتوری هدف بروید
    Dir.chdir(dir) do
      last_mark = print_export(dir, last_mark)
    end
  end
end
----

شما `print_export` را در هر دایرکتوری اجرا می‌کنید، که مانفیست و علامت تصویر قبلی را می‌گیرد و
        مانفیست و علامت این تصویر را برمی‌گرداند؛ به این ترتیب، می‌توانید آن‌ها را به درستی پیوند دهید.
        "علامت" اصطلاح `fast-import` برای یک شناسه است که به یک کامیت می‌دهید؛ وقتی کامیت‌ها را ایجاد
        می‌کنید، به هر یک علامتی می‌دهید که می‌توانید از آن برای پیوند به آن از کامیت‌های دیگر استفاده کنید.
        بنابراین، اولین کاری که باید در متد `print_export` خود انجام دهید این است که یک علامت از نام
        دایرکتوری تولید کنید:

[source,ruby]
----
mark = convert_dir_to_mark(dir)
----

شما این کار را با ایجاد یک آرایه از دایرکتوری‌ها و استفاده از مقدار ایندکس به عنوان علامت انجام می‌دهید، زیرا
        یک علامت باید یک عدد صحیح باشد.
        متد شما به این شکل به نظر می‌رسد:

[source,ruby]
----
$marks = []
def convert_dir_to_mark(dir)
  if !$marks.include?(dir)
    $marks << dir
  end
  ($marks.index(dir) + 1).to_s
end
----

اکنون که یک نمایندگی عددی از کامیت خود دارید، به یک تاریخ برای متاداده کامیت نیاز دارید.
        زیرا تاریخ در نام دایرکتوری بیان شده است، شما آن را تجزیه می‌کنید.
        خط بعدی در فایل `print_export` شما این است:

[source,ruby]
----
date = convert_dir_to_date(dir)
----

که `convert_dir_to_date` به این شکل تعریف شده است:

[source,ruby]
----
def convert_dir_to_date(dir)
  if dir == 'current'
    return Time.now().to_i
  else
    dir = dir.gsub('back_', '')
    (year, month, day) = dir.split('_')
    return Time.local(year, month, day).to_i
  end
end
----

این یک مقدار عددی برای تاریخ هر دایرکتوری برمی‌گرداند.
        آخرین قطعه اطلاعات متاداده‌ای که به هر کامیت نیاز دارید، داده‌های کامیت‌کننده است که شما در یک متغیر جهانی
        سخت‌کد می‌کنید:

[source,ruby]
----
$author = 'John Doe <john@example.com>'
----

اکنون شما آماده‌اید که داده‌های کامیت را برای واردکننده خود چاپ کنید.
        اطلاعات اولیه بیان می‌کند که شما یک شیء کامیت را تعریف می‌کنید و در کدام شاخه است، به دنبال علامتی که تولید
        کرده‌اید، اطلاعات کامیت‌کننده و پیام کامیت، و سپس کامیت قبلی، در صورت وجود.
        کد به این شکل به نظر می‌رسد:

[source,ruby]
----
# چاپ اطلاعات واردات
puts 'commit refs/heads/master'
puts 'mark :' + mark
puts "committer #{$author} #{date} -0700"
export_data('imported from ' + dir)
puts 'from :' + last_mark if last_mark
----

شما زمان منطقه را سخت‌کد می‌کنید (-0700) زیرا انجام این کار آسان است.
        اگر از سیستم دیگری وارد می‌کنید، باید زمان منطقه را به عنوان یک آفست مشخص کنید.
        پیام کامیت باید به یک فرمت خاص بیان شود:

[source]
----
data (size)\n(contents)
----

فرمت شامل کلمه data، اندازه داده‌ای که باید خوانده شود، یک خط جدید و در نهایت داده است.
        زیرا شما نیاز دارید از همان فرمت برای مشخص کردن محتوای فایل‌ها بعداً استفاده کنید، یک متد کمکی به نام `export_data`
        ایجاد می‌کنید:

[source,ruby]
----
def export_data(string)
  print "data #{string.size}\n#{string}"
end
----

تنها چیزی که باقی مانده است مشخص کردن محتوای فایل‌ها برای هر تصویر است.
        این کار آسان است، زیرا شما هر یک را در یک دایرکتوری دارید – می‌توانید دستور `deleteall` را چاپ کنید و
        سپس محتوای هر فایل در دایرکتوری را چاپ کنید.
        سپس گیت هر تصویر را به درستی ثبت می‌کند:

[source,ruby]
----
puts 'deleteall'
Dir.glob("**/*").each do |file|
  next if !File.file?(file)
  inline_data(file)
end
----

توجه: از آنجا که بسیاری از سیستم‌ها تغییرات خود را به عنوان تغییرات از یک کامیت به کامیت دیگر می‌دانند،
        fast-import همچنین می‌تواند دستورات را با هر کامیت بگیرد تا مشخص کند کدام فایل‌ها اضافه، حذف یا تغییر یافته‌اند
        و محتوای جدید چیست.
        شما می‌توانید تفاوت‌ها بین تصاویر را محاسبه کنید و فقط این داده‌ها را ارائه دهید، اما انجام این کار پیچیده‌تر
        است – شما می‌توانید به سادگی به گیت تمام داده‌ها را بدهید و بگذارید خودش آن را حل کند.
        اگر این برای داده‌های شما بهتر است، به صفحه man `fast-import` برای جزئیات در مورد نحوه ارائه داده‌های
        خود به این روش مراجعه کنید.

فرمت برای فهرست کردن محتوای فایل‌های جدید یا مشخص کردن یک فایل تغییر یافته با محتوای جدید به شکل زیر است:

[source]
----
M 644 inline path/to/file
data (size)
(file contents)
----

در اینجا، 644 حالت است (اگر فایل‌های اجرایی دارید، باید آن را شناسایی کرده و به 755 مشخص کنید)، و inline
        می‌گوید که شما محتوای آن را بلافاصله بعد از این خط فهرست خواهید کرد.
        متد `inline_data` شما به این شکل به نظر می‌رسد:

[source,ruby]
----
def inline_data(file, code = 'M', mode = '644')
  content = File.read(file)
  puts "#{code} #{mode} inline #{file}"
  export_data(content)
end
----

شما از متد `export_data` که قبلاً تعریف کرده‌اید استفاده می‌کنید، زیرا این همان روشی است که داده‌های
        پیام کامیت خود را مشخص کرده‌اید.

آخرین چیزی که باید انجام دهید این است که علامت فعلی را برگردانید تا بتوانید آن را به تکرار بعدی منتقل کنید:

[source,ruby]
----
return mark
----

[NOTE]
====
اگر شما در حال اجرای ویندوز هستید، باید مطمئن شوید که یک مرحله اضافی اضافه کنید.
                همانطور که قبلاً ذکر شد، ویندوز برای کاراکترهای خط جدید از CRLF استفاده می‌کند در حالی که `git
                  fast-import` فقط LF را انتظار دارد.
                برای دور زدن این مشکل و خوشحال کردن `git fast-import`، شما باید به Ruby بگویید که از LF به
                جای CRLF استفاده کند:

[source,ruby]
----
$stdout.binmode
----
====

این همه است.
        در اینجا اسکریپت به طور کامل آمده است:


[source,ruby]
----
#!/usr/bin/env ruby

$stdout.binmode
$author = "John Doe <john@example.com>"

$marks = []
def convert_dir_to_mark(dir)
    if !$marks.include?(dir)
        $marks << dir
    end
    ($marks.index(dir)+1).to_s
end

def convert_dir_to_date(dir)
    if dir == 'current'
        return Time.now().to_i
    else
        dir = dir.gsub('back_', '')
        (year, month, day) = dir.split('_')
        return Time.local(year, month, day).to_i
    end
end

def export_data(string)
    print "data #{string.size}\n#{string}"
end

def inline_data(file, code='M', mode='644')
    content = File.read(file)
    puts "#{code} #{mode} inline #{file}"
    export_data(content)
end

def print_export(dir, last_mark)
    date = convert_dir_to_date(dir)
    mark = convert_dir_to_mark(dir)

    puts 'commit refs/heads/master'
    puts "mark :#{mark}"
    puts "committer #{$author} #{date} -0700"
    export_data("imported from #{dir}")
    puts "from :#{last_mark}" if last_mark

    puts 'deleteall'
    Dir.glob("**/*").each do |file|
        next if !File.file?(file)
        inline_data(file)
    end
    mark
end

# حلقه از طریق دایرکتوری‌ها
last_mark = nil
Dir.chdir(ARGV[0]) do
    Dir.glob("*").each do |dir|
        next if File.file?(dir)

        # به دایرکتوری هدف بروید
        Dir.chdir(dir) do
            last_mark = print_export(dir, last_mark)
        end
    end
end
----

اگر این اسکریپت را اجرا کنید، محتوایی به شکل زیر خواهید داشت:

[source,console]
----
$ ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe <john@example.com> 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
# Hello

This is my readme.
commit refs/heads/master
mark :2
committer John Doe <john@example.com> 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
#!/bin/env ruby

puts "Hey there"
M 644 inline README.md
(...)
----

برای اجرای واردکننده، این خروجی را از طریق `git fast-import` در حالی که در دایرکتوری گیت هستید که
        می‌خواهید به آن وارد کنید، هدایت کنید.
        شما می‌توانید یک دایرکتوری جدید ایجاد کنید و سپس در آن `git init` را اجرا کنید تا نقطه شروعی داشته
        باشید، و سپس اسکریپت خود را اجرا کنید:

[source,console]
----
$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:       5000
Total objects:           13 (         6 duplicates                  )
      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)
      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)
      commits:            4 (         1 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              2
Memory total:          2344 KiB
       pools:          2110 KiB
     objects:          234 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         10
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          2 /          2
pack_report: pack_mapped              =       1457 /       1457
---------------------------------------------------------------------
----

همانطور که می‌بینید، وقتی که با موفقیت کامل می‌شود، به شما تعدادی آمار درباره آنچه که انجام داده است می‌دهد.
        در این مورد، شما در مجموع 13 شیء برای 4 کامیت به 1 شاخه وارد کرده‌اید.
        اکنون، می‌توانید `git log` را اجرا کنید تا تاریخچه جدید خود را ببینید:

[source,console]
----
$ git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe <john@example.com>
Date:   Tue Jul 29 19:39:04 2014 -0700

    imported from current

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe <john@example.com>
Date:   Mon Feb 3 01:00:00 2014 -0700

    imported from back_2014_02_03
----

این است – یک مخزن گیت زیبا و تمیز.
        مهم است که توجه داشته باشید که هیچ چیزی چک‌اوت نشده است – شما در ابتدا هیچ فایلی در دایرکتوری کاری خود ندارید.
        برای دریافت آن‌ها، باید شاخه خود را به جایی که `master` اکنون است بازنشانی کنید:

[source,console]
----
$ ls
$ git reset --hard master
HEAD is now at 3caa046 imported from current
$ ls
README.md main.rb
----

شما می‌توانید کارهای بیشتری با ابزار `fast-import` انجام دهید – حالت‌های مختلف، داده‌های باینری،
        چندین شاخه و ادغام، برچسب‌ها، نشانگرهای پیشرفت و بیشتر.
        تعدادی از مثال‌های سناریوهای پیچیده‌تر در دایرکتوری `contrib/fast-import` کد منبع گیت موجود است.
