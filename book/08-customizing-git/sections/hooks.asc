[[_git_hooks]]
=== هوک‌های گیت

(((hooks)))
مانند بسیاری از سیستم‌های کنترل نسخه دیگر، گیت راهی برای اجرای اسکریپت‌های سفارشی هنگام وقوع برخی از اقدامات مهم دارد.
    این هوک‌ها به دو گروه تقسیم می‌شوند: هوک‌های سمت کلاینت و هوک‌های سمت سرور.
    هوک‌های سمت کلاینت توسط عملیاتی مانند کامیت و ادغام فعال می‌شوند، در حالی که هوک‌های سمت سرور در عملیات شبکه مانند دریافت کامیت‌های ارسال شده اجرا می‌شوند.
    شما می‌توانید از این هوک‌ها برای انواع مختلفی از دلایل استفاده کنید.

==== نصب یک هوک

تمام هوک‌ها در زیرپوشه `hooks` دایرکتوری گیت ذخیره می‌شوند.
      در بیشتر پروژه‌ها، این دایرکتوری `.git/hooks` است.
      زمانی که شما یک مخزن جدید با `git init` راه‌اندازی می‌کنید، گیت دایرکتوری هوک را با تعدادی اسکریپت نمونه پر می‌کند که بسیاری از آن‌ها به خودی خود مفید هستند؛ اما همچنین ورودی‌های هر اسکریپت را مستند می‌کنند.
      تمام مثال‌ها به عنوان اسکریپت‌های شل نوشته شده‌اند، با مقداری پرل در آن‌ها، اما هر اسکریپت اجرایی با نام مناسب به خوبی کار خواهد کرد – شما می‌توانید آن‌ها را به زبان روبی یا پایتون یا هر زبانی که با آن آشنا هستید بنویسید.
      اگر می‌خواهید از اسکریپت‌های هوک بسته‌بندی شده استفاده کنید، باید نام آن‌ها را تغییر دهید؛ نام فایل‌های آن‌ها همه با `.sample` پایان می‌یابد.

برای فعال‌سازی یک اسکریپت هوک، فایلی را در زیرپوشه `hooks` دایرکتوری .git خود قرار دهید که به طور مناسب نام‌گذاری شده باشد (بدون هیچ پسوندی) و قابل اجرا باشد.
      از آن نقطه به بعد، باید فراخوانی شود.
      ما در اینجا بیشتر نام‌های هوک‌های اصلی را پوشش خواهیم داد.

==== هوک‌های سمت کلاینت

هوک‌های زیادی در سمت کلاینت وجود دارد.
      این بخش آن‌ها را به هوک‌های جریان کاری کامیت، اسکریپت‌های جریان کاری ایمیل و سایر موارد تقسیم می‌کند.

[NOTE]
====
مهم است که توجه داشته باشید که هوک‌های سمت کلاینت *کپی نمی‌شوند* زمانی که شما یک مخزن را کلون می‌کنید.
              اگر هدف شما از این اسکریپت‌ها تحمیل یک سیاست است، احتمالاً می‌خواهید این کار را در سمت سرور انجام دهید؛ به مثال در <<_an_example_git_enforced_policy#_an_example_git_enforced_policy>> مراجعه کنید.
====

===== هوک‌های جریان کاری کامیت

چهار هوک اول مربوط به فرآیند کامیت هستند.

هوک `pre-commit` ابتدا اجرا می‌شود، قبل از اینکه شما حتی یک پیام کامیت وارد کنید.
        این هوک برای بررسی نمایه‌ای که قرار است کامیت شود، استفاده می‌شود تا ببیند آیا چیزی را فراموش کرده‌اید، اطمینان حاصل کند که تست‌ها اجرا می‌شوند، یا هر چیزی که نیاز دارید در کد بررسی کنید.
        خروجی غیرصفر از این هوک کامیت را متوقف می‌کند، اگرچه می‌توانید با `git commit --no-verify` آن را دور بزنید.
        شما می‌توانید کارهایی مانند بررسی سبک کد (اجرا کردن `lint` یا چیزی معادل آن)، بررسی فاصله‌های اضافی (هوک پیش‌فرض دقیقاً همین کار را انجام می‌دهد)، یا بررسی مستندات مناسب در مورد متدهای جدید انجام دهید.

هوک `prepare-commit-msg` قبل از اینکه ویرایشگر پیام کامیت باز شود اما بعد از ایجاد پیام پیش‌فرض اجرا می‌شود.
        این هوک به شما اجازه می‌دهد تا پیام پیش‌فرض را قبل از اینکه نویسنده کامیت آن را ببیند ویرایش کنید.
        این هوک چند پارامتر می‌گیرد: مسیر فایلی که پیام کامیت را تا کنون نگه می‌دارد، نوع کامیت و SHA-1 کامیت اگر این یک کامیت اصلاح شده باشد.
        این هوک معمولاً برای کامیت‌های عادی مفید نیست؛ بلکه برای کامیت‌هایی که پیام پیش‌فرض به صورت خودکار تولید می‌شود، مانند پیام‌های کامیت الگو، کامیت‌های ادغام، کامیت‌های فشرده و کامیت‌های اصلاح شده خوب است.
        شما می‌توانید از آن به همراه یک الگوی کامیت برای به‌طور برنامه‌نویسی اطلاعات را وارد کنید.

هوک `commit-msg` یک پارامتر می‌گیرد، که دوباره مسیر یک فایل موقت است که شامل پیام کامیت نوشته شده توسط توسعه‌دهنده است.
        اگر این اسکریپت خروجی غیرصفر داشته باشد، گیت فرآیند کامیت را متوقف می‌کند، بنابراین می‌توانید از آن برای اعتبارسنجی وضعیت پروژه یا پیام کامیت خود قبل از اجازه دادن به کامیت استفاده کنید.
        در بخش آخر این فصل، ما استفاده از این هوک را برای بررسی اینکه آیا پیام کامیت شما با یک الگوی مورد نیاز مطابقت دارد، نشان خواهیم داد.

پس از اتمام کل فرآیند کامیت، هوک `post-commit` اجرا می‌شود.
        این هوک هیچ پارامتری نمی‌گیرد، اما می‌توانید به راحتی آخرین کامیت را با اجرای `git log -1 HEAD` به دست آورید.
        به طور کلی، این اسکریپت برای اطلاع‌رسانی یا چیزی مشابه استفاده می‌شود.

[[_email_hooks]]
===== هوک‌های جریان کاری ایمیل

شما می‌توانید سه هوک سمت کلاینت برای یک جریان کاری مبتنی بر ایمیل تنظیم کنید.
        همه آن‌ها توسط دستور `git am` فراخوانی می‌شوند، بنابراین اگر شما از آن دستور در جریان کاری خود استفاده نمی‌کنید، می‌توانید با خیال راحت به بخش بعدی بروید.
        اگر شما پچ‌ها را از طریق ایمیل که با `git format-patch` آماده شده‌اند، می‌گیرید، برخی از این‌ها ممکن است برای شما مفید باشند.

اولین هوکی که اجرا می‌شود `applypatch-msg` است.
        این هوک یک آرگومان می‌گیرد: نام فایل موقتی که شامل پیام کامیت پیشنهادی است.
        اگر این اسکریپت خروجی غیرصفر داشته باشد، گیت پچ را رد می‌کند.
        شما می‌توانید از این هوک برای اطمینان از اینکه پیام کامیت به درستی فرمت شده است، یا برای نرمال‌سازی پیام با ویرایش آن در محل استفاده کنید.

هوک بعدی که هنگام اعمال پچ‌ها از طریق `git am` اجرا می‌شود `pre-applypatch` است.
        به طرز گیج‌کننده‌ای، این هوک _بعد از_ اینکه پچ اعمال شد اما قبل از اینکه کامیت انجام شود، اجرا می‌شود، بنابراین می‌توانید از آن برای بررسی نمایه قبل از انجام کامیت استفاده کنید.
        شما می‌توانید با این اسکریپت تست‌ها را اجرا کنید یا به هر نحوی نمایه کاری را بررسی کنید.
        اگر چیزی کم باشد یا تست‌ها پاس نشوند، خروجی غیرصفر، اسکریپت `git am` را بدون کامیت کردن پچ متوقف می‌کند.

آخرین هوکی که در حین عملیات `git am` اجرا می‌شود `post-applypatch` است که بعد از انجام کامیت اجرا می‌شود.
        شما می‌توانید از آن برای اطلاع‌رسانی به یک گروه یا نویسنده پچ که شما آن را وارد کرده‌اید، استفاده کنید.
        شما نمی‌توانید با این اسکریپت فرآیند پچ را متوقف کنید.

[[_other_client_hooks]]
===== سایر هوک‌های کلاینت

هوک `pre-rebase` قبل از اینکه شما هر چیزی را بازنویسی کنید اجرا می‌شود و می‌تواند فرآیند را با خروجی غیرصفر متوقف کند.
        شما می‌توانید از این هوک برای جلوگیری از بازنویسی هر کامیتی که قبلاً ارسال شده است، استفاده کنید.
        هوک `pre-rebase` نمونه‌ای که گیت نصب می‌کند این کار را انجام می‌دهد، اگرچه برخی فرضیات را انجام می‌دهد که ممکن است با جریان کاری شما مطابقت نداشته باشد.

هوک `post-rewrite` توسط دستوراتی که کامیت‌ها را جایگزین می‌کنند، مانند `git commit --amend` و `git rebase` (اگرچه نه توسط `git filter-branch`) اجرا می‌شود.
        آرگومان واحد آن این است که کدام دستور باعث بازنویسی شده است و لیستی از بازنویسی‌ها را در `stdin` دریافت می‌کند.
        این هوک بسیاری از همان کاربردها را دارد که هوک‌های `post-checkout` و `post-merge` دارند.

پس از اینکه شما یک `git checkout` موفق را اجرا کردید، هوک `post-checkout` اجرا می‌شود؛ شما می‌توانید از آن برای تنظیم دایرکتوری کاری خود به درستی برای محیط پروژه‌تان استفاده کنید.
        این ممکن است به معنای جابجایی فایل‌های باینری بزرگ باشد که نمی‌خواهید تحت کنترل منبع باشند، تولید خودکار مستندات، یا چیزی در این راستا باشد.

هوک `post-merge` پس از یک دستور `merge` موفق اجرا می‌شود.
        شما می‌توانید از آن برای بازیابی داده‌ها در نمایه کاری که گیت نمی‌تواند ردیابی کند، مانند داده‌های مجوز استفاده کنید.
        این هوک همچنین می‌تواند وجود فایل‌های خارجی که ممکن است بخواهید در هنگام تغییر نمایه کاری کپی شوند را اعتبارسنجی کند.

هوک `pre-push` در حین `git push` اجرا می‌شود، پس از اینکه مراجع راه دور به‌روزرسانی شده‌اند اما قبل از اینکه هیچ شیئی منتقل شود.
        این هوک نام و مکان راه دور را به عنوان پارامترها دریافت می‌کند و لیستی از مراجع به‌روزرسانی شده را از طریق `stdin` دریافت می‌کند.
        شما می‌توانید از آن برای اعتبارسنجی مجموعه‌ای از به‌روزرسانی‌های مرجع قبل از وقوع یک پش استفاده کنید (کد خروج غیرصفر، پش را متوقف می‌کند).

گیت به طور دوره‌ای جمع‌آوری زباله را به عنوان بخشی از عملیات عادی خود انجام می‌دهد، با فراخوانی `git gc --auto`.
        هوک `pre-auto-gc` درست قبل از انجام جمع‌آوری زباله فراخوانی می‌شود و می‌تواند برای اطلاع‌رسانی به شما که این اتفاق در حال وقوع است، یا برای متوقف کردن جمع‌آوری در صورتی که اکنون زمان مناسبی نیست، استفاده شود.

==== هوک‌های سمت سرور

علاوه بر هوک‌های سمت کلاینت، شما می‌توانید به عنوان یک مدیر سیستم از چند هوک مهم سمت سرور برای تحمیل تقریباً هر نوع سیاستی برای پروژه خود استفاده کنید.
      این اسکریپت‌ها قبل و بعد از پش‌ها به سرور اجرا می‌شوند.
      هوک‌های پیش می‌توانند در هر زمان با خروجی غیرصفر پش را رد کنند و همچنین می‌توانند پیام خطای خود را به کلاینت چاپ کنند؛ شما می‌توانید یک سیاست پش تنظیم کنید که به پیچیدگی دلخواه شما باشد.

===== `pre-receive`

اولین اسکریپت که هنگام پردازش یک پش از یک کلاینت اجرا می‌شود `pre-receive` است.
        این هوک لیستی از مراجع را که از stdin پش می‌شوند، می‌گیرد؛ اگر خروجی غیرصفر داشته باشد، هیچ‌کدام از آن‌ها پذیرفته نمی‌شوند.
        شما می‌توانید از این هوک برای کارهایی مانند اطمینان از اینکه هیچ‌یک از مراجع به‌روزرسانی شده غیر پیشرفته نیستند، یا برای انجام کنترل دسترسی برای تمام مراجع و فایل‌هایی که با پش تغییر می‌کنند، استفاده کنید.

===== `update`

اسکریپت `update` بسیار مشابه اسکریپت `pre-receive` است، با این تفاوت که یک بار برای هر شاخه‌ای که پش‌کننده سعی دارد به‌روزرسانی کند، اجرا می‌شود.
        اگر پش‌کننده سعی کند به چندین شاخه پش کند، `pre-receive` فقط یک بار اجرا می‌شود، در حالی که `update` یک بار برای هر شاخه‌ای که به آن پش می‌شود، اجرا می‌شود.
        به جای خواندن از stdin، این اسکریپت سه آرگومان می‌گیرد: نام مرجع (شاخه)، SHA-1 که مرجع قبل از پش به آن اشاره می‌کرد، و SHA-1 که کاربر سعی دارد پش کند.
        اگر اسکریپت update خروجی غیرصفر داشته باشد، فقط آن مرجع رد می‌شود؛ مراجع دیگر همچنان می‌توانند به‌روزرسانی شوند.

===== `post-receive`

هوک `post-receive` پس از اتمام کل فرآیند اجرا می‌شود و می‌تواند برای به‌روزرسانی خدمات دیگر یا اطلاع‌رسانی به کاربران استفاده شود.
        این هوک همان داده‌های stdin را به عنوان هوک `pre-receive` می‌گیرد.
        مثال‌ها شامل ارسال ایمیل به یک لیست، اطلاع‌رسانی به یک سرور یکپارچه‌سازی مداوم، یا به‌روزرسانی یک سیستم ردیابی بلیط است – شما حتی می‌توانید پیام‌های کامیت را تجزیه کنید تا ببینید آیا بلیط‌هایی وجود دارند که باید باز، ویرایش یا بسته شوند.
        این اسکریپت نمی‌تواند فرآیند پش را متوقف کند، اما کلاینت تا زمانی که این فرآیند کامل نشده است، قطع نمی‌شود، بنابراین اگر سعی کنید کاری انجام دهید که ممکن است زمان زیادی ببرد، احتیاط کنید.
