[[_an_example_git_enforced_policy]]
=== یک مثال از سیاست‌های تحمیلی گیت

(((policy example)))
در این بخش، شما از آنچه که آموخته‌اید برای ایجاد یک جریان کاری گیت استفاده خواهید کرد که فرمت خاصی برای پیام‌های
      کامیت را بررسی می‌کند و اجازه می‌دهد تنها کاربران خاصی به تغییر زیرپوشه‌های خاصی در یک پروژه دسترسی داشته باشند.
      شما اسکریپت‌های کلاینتی خواهید ساخت که به توسعه‌دهنده کمک می‌کند تا بداند آیا ارسال آن‌ها رد خواهد شد و
      اسکریپت‌های سروری که واقعاً سیاست‌ها را تحمیل می‌کنند.

اسکریپت‌هایی که نشان خواهیم داد به زبان روبی نوشته شده‌اند؛ بخشی به دلیل تنبلی فکری ما، اما همچنین به این دلیل که
      روبی خواندنش آسان است، حتی اگر نتوانید لزوماً آن را بنویسید.
      با این حال، هر زبانی کار می‌کند – تمام اسکریپت‌های نمونه هوک توزیع شده با گیت یا به زبان پرل یا بش هستند، بنابراین
      می‌توانید نمونه‌های زیادی از هوک‌ها در آن زبان‌ها را با نگاه کردن به نمونه‌ها ببینید.

==== هوک سمت سرور

تمام کارهای سمت سرور در فایل `update` در دایرکتوری `hooks` شما قرار خواهد گرفت.
        هوک `update` یک بار برای هر شاخه‌ای که به آن ارسال می‌شود اجرا می‌شود و سه آرگومان می‌گیرد:

* نام مرجع‌ای که به آن ارسال می‌شود
* نسخه قدیمی که آن شاخه بود
* نسخه جدیدی که ارسال می‌شود

شما همچنین به کاربری که در حال ارسال است دسترسی دارید اگر ارسال از طریق SSH انجام شود.
        اگر به همه اجازه داده‌اید که با یک کاربر واحد (مانند "git") از طریق احراز هویت کلید عمومی متصل شوند، ممکن است
        مجبور شوید که آن کاربر را به یک پوشش شل بدهید که تعیین کند کدام کاربر بر اساس کلید عمومی متصل می‌شود و یک متغیر
        محیطی را به‌طور مناسب تنظیم کند.
        در اینجا فرض می‌کنیم که کاربر متصل در متغیر محیطی `$USER` قرار دارد، بنابراین اسکریپت به‌روزرسانی شما
        با جمع‌آوری تمام اطلاعاتی که نیاز دارید آغاز می‌شود:

[source,ruby]
----
#!/usr/bin/env ruby

$refname = ARGV[0]
$oldrev  = ARGV[1]
$newrev  = ARGV[2]
$user    = ENV['USER']

puts "تحمیل سیاست‌ها..."
puts "(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev[0,6]})"
----

بله، این‌ها متغیرهای جهانی هستند.
        قضاوت نکنید – این روش آسان‌تر برای نشان دادن است.

[[_enforcing_commit_message_format]]
===== تحمیل فرمت خاص پیام کامیت

چالش اول شما این است که اطمینان حاصل کنید که هر پیام کامیت به یک فرمت خاص پایبند است.
          فقط برای داشتن یک هدف، فرض کنید که هر پیام باید شامل یک رشته باشد که شبیه به "ref: 1234" است زیرا می‌خواهید هر
          کامیت به یک مورد کاری در سیستم بلیط شما لینک شود.
          شما باید به هر کامیتی که در حال ارسال است نگاه کنید، ببینید آیا آن رشته در پیام کامیت وجود دارد و اگر رشته در
          هیچ یک از کامیت‌ها غایب باشد، با خروج غیرصفر از اسکریپت خارج شوید تا ارسال رد شود.

شما می‌توانید لیستی از مقادیر SHA-1 تمام کامیت‌هایی که در حال ارسال هستند را با گرفتن مقادیر
          `$newrev` و `$oldrev` و ارسال آن‌ها به یک دستور لوله گیت به نام `git
            rev-list` به دست آورید.
          این اساساً دستور `git log` است، اما به‌طور پیش‌فرض فقط مقادیر SHA-1 را چاپ می‌کند و هیچ اطلاعات
          دیگری را نشان نمی‌دهد.
          بنابراین، برای به دست آوردن لیستی از تمام SHA-1های کامیت معرفی شده بین یک SHA-1 کامیت و دیگری، می‌توانید چیزی
          شبیه به این را اجرا کنید:

[source,console]
----
$ git rev-list 538c33..d14fc7
d14fc7c847ab946ec39590d87783c69b031bdfb7
9f585da4401b0a3999e84113824d15245c13f0be
234071a1be950e2a8d078e6141f5cd20c1e61ad3
dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a
17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475
----

شما می‌توانید آن خروجی را بگیرید، از طریق هر یک از آن SHA-1های کامیت حلقه بزنید، پیام آن را بگیرید و آن پیام
          را با یک عبارت منظم که به دنبال یک الگو می‌گردد آزمایش کنید.

شما باید بفهمید چگونه می‌توانید پیام کامیت را از هر یک از این کامیت‌ها برای آزمایش به دست آورید.
          برای به دست آوردن داده‌های خام کامیت، می‌توانید از یک دستور لوله دیگر به نام `git cat-file` استفاده
          کنید.
          ما تمام این دستورات لوله را به تفصیل در <<ch10-git-internals#ch10-git-internals>> بررسی خواهیم کرد؛ اما در حال حاضر، این چیزی است که آن دستور به شما می‌دهد:

[source,console]
----
$ git cat-file commit ca82a6
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon <schacon@gmail.com> 1205815931 -0700
committer Scott Chacon <schacon@gmail.com> 1240030591 -0700

تغییر شماره نسخه
----

یک روش ساده برای به دست آوردن پیام کامیت از یک کامیت زمانی که شما مقدار SHA-1 را دارید این است که به اولین خط
          خالی بروید و همه چیز بعد از آن را بگیرید.
          شما می‌توانید این کار را با دستور `sed` در سیستم‌های یونیکس انجام دهید:

[source,console]
----
$ git cat-file commit ca82a6 | sed '1,/^$/d'
تغییر شماره نسخه
----

شما می‌توانید از آن جادو برای گرفتن پیام کامیت از هر کامیتی که در حال تلاش برای ارسال است استفاده کنید و اگر
          چیزی را ببینید که با آن مطابقت ندارد، خارج شوید.
          برای خروج از اسکریپت و رد کردن ارسال، غیرصفر خارج شوید.
          کل روش به این صورت است:

[source,ruby]
----
$regex = /\[ref: (\d+)\]/

# تحمیل فرمت پیام کامیت سفارشی
def check_message_format
  missed_revs = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  missed_revs.each do |rev|
    message = `git cat-file commit #{rev} | sed '1,/^$/d'`
    if !$regex.match(message)
      puts "[سیاست] پیام شما به درستی فرمت نشده است"
      exit 1
    end
  end
end
check_message_format
----

قرار دادن آن در اسکریپت `update` شما به‌روزرسانی‌هایی را که شامل کامیت‌هایی هستند که پیام‌های
          آن‌ها به قانون شما پایبند نیستند، رد خواهد کرد.

===== تحمیل یک سیستم ACL مبتنی بر کاربر

فرض کنید می‌خواهید مکانیزمی اضافه کنید که از یک لیست کنترل دسترسی (ACL) استفاده می‌کند که مشخص می‌کند کدام
          کاربران مجاز به ارسال تغییرات به کدام قسمت‌های پروژه‌های شما هستند.
          برخی افراد دسترسی کامل دارند و دیگران فقط می‌توانند تغییرات را به زیرپوشه‌های خاص یا فایل‌های خاص ارسال کنند.
          برای تحمیل این، شما این قوانین را به فایلی به نام `acl` می‌نویسید که در مخزن گیت خالی شما در سرور
          قرار دارد.
          شما هوک `update` را به این قوانین نگاه می‌کنید، می‌بینید که چه فایل‌هایی برای تمام کامیت‌های ارسال
          شده معرفی شده‌اند و تعیین می‌کنید که آیا کاربر در حال ارسال به‌روزرسانی به همه این فایل‌ها دسترسی دارد یا خیر.

اولین کاری که انجام می‌دهید این است که ACL خود را بنویسید.
          در اینجا از فرمت بسیار شبیه به مکانیزم ACL CVS استفاده می‌کنید: این فرمت شامل یک سری خطوط است که در آن اولین
          فیلد `avail` یا `unavail` است، فیلد بعدی یک لیست جدا شده با کاما از کاربرانی است که
          قانون به آن‌ها اعمال می‌شود و آخرین فیلد مسیری است که قانون به آن اعمال می‌شود (خالی به معنای دسترسی باز است).
          تمام این فیلدها با یک کاراکتر لوله (`|`) جدا شده‌اند.

در این مورد، شما چند مدیر، برخی نویسندگان مستندات با دسترسی به دایرکتوری `doc` و یک توسعه‌دهنده که
          فقط به دایرکتوری‌های `lib` و `tests` دسترسی دارد، دارید و فایل ACL شما به این صورت است:

[source]
----
avail|nickh,pjhyett,defunkt,tpw
avail|usinclair,cdickens,ebronte|doc
avail|schacon|lib
avail|schacon|tests
----

شما با خواندن این داده‌ها به یک ساختار که می‌توانید از آن استفاده کنید، شروع می‌کنید.
          در این مورد، برای ساده نگه داشتن مثال، شما فقط دستورات `avail` را تحمیل خواهید کرد.
          در اینجا یک متد است که به شما یک آرایه انجمنی می‌دهد که در آن کلید نام کاربر و مقدار آن آرایه‌ای از مسیرهایی
          است که کاربر به آن‌ها دسترسی نوشتن دارد:

[source,ruby]
----
def get_acl_access_data(acl_file)
  # خواندن داده‌های ACL
  acl_file = File.read(acl_file).split("\n").reject { |line| line == '' }
  access = {}
  acl_file.each do |line|
    avail, users, path = line.split('|')
    next unless avail == 'avail'
    users.split(',').each do |user|
      access[user] ||= []
      access[user] << path
    end
  end
  access
end
----

در فایل ACL که قبلاً به آن نگاه کردید، این متد `get_acl_access_data` یک ساختار داده‌ای را
          برمی‌گرداند که به این صورت است:

[source,ruby]
----
{"defunkt"=>[nil],
 "tpw"=>[nil],
 "nickh"=>[nil],
 "pjhyett"=>[nil],
 "schacon"=>["lib", "tests"],
 "cdickens"=>["doc"],
 "usinclair"=>["doc"],
 "ebronte"=>["doc"]}
----

حالا که مجوزها را مرتب کرده‌اید، باید تعیین کنید که کدام مسیرها توسط کامیت‌های ارسال شده تغییر یافته‌اند،
          بنابراین می‌توانید مطمئن شوید که کاربری که در حال ارسال است به همه آن‌ها دسترسی دارد.

شما می‌توانید به راحتی ببینید که چه فایل‌هایی در یک کامیت واحد تغییر یافته‌اند با گزینه
          `--name-only` به دستور `git log` (که به‌طور مختصر در <<ch02-git-basics-chapter#ch02-git-basics-chapter>> ذکر شده است):

[source,console]
----
$ git log -1 --name-only --pretty=format:'' 9f585d

README
lib/test.rb
----

اگر از ساختار ACL که از متد `get_acl_access_data` برگشت داده شده استفاده کنید و آن را با فایل‌های
          لیست شده در هر یک از کامیت‌ها بررسی کنید، می‌توانید تعیین کنید که آیا کاربر دسترسی به ارسال همه کامیت‌های خود
          را دارد یا خیر:

[source,ruby]
----
# فقط اجازه می‌دهد کاربران خاصی زیرپوشه‌های خاصی را در یک پروژه تغییر دهند
def check_directory_perms
  access = get_acl_access_data('acl')

  # ببینید آیا کسی در حال تلاش برای ارسال چیزی است که نمی‌تواند
  new_commits = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  new_commits.each do |rev|
    files_modified = `git log -1 --name-only --pretty=format:'' #{rev}`.split("\n")
    files_modified.each do |path|
      next if path.size == 0
      has_file_access = false
      access[$user].each do |access_path|
        if !access_path  # کاربر به همه چیز دسترسی دارد
           || (path.start_with? access_path) # دسترسی به این مسیر
          has_file_access = true
        end
      end
      if !has_file_access
        puts "[سیاست] شما به ارسال به #{path} دسترسی ندارید"
        exit 1
      end
    end
  end
end

check_directory_perms
----

شما با استفاده از `git rev-list` لیستی از کامیت‌های جدیدی که به سرور شما ارسال می‌شوند را به دست
          می‌آورید.
          سپس، برای هر یک از آن کامیت‌ها، فایل‌هایی که تغییر یافته‌اند را پیدا می‌کنید و مطمئن می‌شوید که کاربر که در
          حال ارسال است به همه مسیرهای تغییر یافته دسترسی دارد.

حالا کاربران شما نمی‌توانند هیچ کامیتی را با پیام‌های بدفرمت یا با فایل‌های تغییر یافته خارج از مسیرهای تعیین
          شده خود ارسال کنند.

===== آزمایش آن

اگر شما `chmod u+x .git/hooks/update` را اجرا کنید، که فایلی است که باید تمام این کد را در آن قرار
          داده باشید، و سپس سعی کنید یک کامیت با پیام غیرقابل قبول ارسال کنید، چیزی شبیه به این دریافت می‌کنید:

[source,console]
----
$ git push -f origin master
شمارش اشیاء: 5، انجام شد.
فشرده‌سازی اشیاء: 100% (3/3)، انجام شد.
نوشتن اشیاء: 100% (3/3)، 323 بایت، انجام شد.
جمع کل 3 (دلتا 1)، دوباره استفاده شده 0 (دلتا 0)
باز کردن اشیاء: 100% (3/3)، انجام شد.
تحمیل سیاست‌ها...
(refs/heads/master) (8338c5) (c5b616)
[سیاست] پیام شما به درستی فرمت نشده است
خطا: hooks/update با کد خطای 1 خارج شد
خطا: هوک به‌روزرسانی را رد کرد
به git@gitserver:project.git
 ! [رد شده از راه دور] master -&gt; master (هوک رد شد)
خطا: ارسال برخی از مراجع به 'git@gitserver:project.git' ناموفق بود
----

چند چیز جالب در اینجا وجود دارد.
          اولاً، شما اینجا را می‌بینید که هوک شروع به اجرا می‌کند.

[source,console]
----
تحمیل سیاست‌ها...
(refs/heads/master) (fb8c72) (c56860)
----

به یاد داشته باشید که شما این را در ابتدای اسکریپت به‌روزرسانی خود چاپ کردید.
          هر چیزی که اسکریپت شما به `stdout` چاپ کند به کلاینت منتقل خواهد شد.

چیز بعدی که متوجه خواهید شد پیام خطا است.

[source,console]
----
[سیاست] پیام شما به درستی فرمت نشده است
خطا: hooks/update با کد خطای 1 خارج شد
خطا: هوک به‌روزرسانی را رد کرد
----

خط اول توسط شما چاپ شده است، دو خط دیگر گیت به شما می‌گوید که اسکریپت به‌روزرسانی غیرصفر خارج شده و این همان
          چیزی است که ارسال شما را رد می‌کند.
          در نهایت، شما این را دارید:

[source,console]
----
به git@gitserver:project.git
 ! [رد شده از راه دور] master -&gt; master (هوک رد شد)
خطا: ارسال برخی از مراجع به 'git@gitserver:project.git' ناموفق بود
----

شما یک پیام رد شده از راه دور برای هر مرجعی که هوک شما رد کرده است خواهید دید و به شما می‌گوید که به‌طور خاص
          به دلیل یک خطای هوک رد شده است.

علاوه بر این، اگر کسی سعی کند فایلی را که به آن دسترسی ندارد و کامیتی حاوی آن را ارسال کند ویرایش کند، چیزی
          مشابه خواهد دید.
          برای مثال، اگر یک نویسنده مستندات سعی کند یک کامیت را که چیزی در دایرکتوری `lib` را تغییر می‌دهد
          ارسال کند، او این را می‌بیند:

[source,console]
----
[سیاست] شما به ارسال به lib/test.rb دسترسی ندارید
----

از این پس، به شرطی که آن اسکریپت `update` وجود داشته باشد و قابل اجرا باشد، مخزن شما هرگز پیام
          کامیتی بدون الگوی شما نخواهد داشت و کاربران شما در یک محیط محدود خواهند بود.

==== هوک‌های سمت کلاینت

معایب این رویکرد این است که ناله‌ای که به طور حتم زمانی که ارسال‌های کامیت کاربران شما رد می‌شود، به وجود
        می‌آید.
        رد کردن کارهای به دقت طراحی شده آن‌ها در آخرین لحظه می‌تواند بسیار ناامیدکننده و گیج‌کننده باشد؛ و علاوه بر این،
        آن‌ها باید تاریخچه خود را ویرایش کنند تا آن را اصلاح کنند، که همیشه برای افراد ضعیف نیست.

پاسخ به این معضل این است که برخی هوک‌های سمت کلاینت را ارائه دهید که کاربران می‌توانند برای اطلاع از زمانی که
        در حال انجام کاری هستند که احتمالاً سرور آن را رد خواهد کرد، اجرا کنند.
        به این ترتیب، آن‌ها می‌توانند هر گونه مشکلی را قبل از کامیت کردن و قبل از اینکه آن مسائل دشوارتر شود، اصلاح
        کنند.
        زیرا هوک‌ها با یک کپی از یک پروژه منتقل نمی‌شوند، شما باید این اسکریپت‌ها را به روشی دیگر توزیع کنید و سپس از
        کاربران خود بخواهید که آن‌ها را به دایرکتوری `.git/hooks` خود کپی کنند و آن‌ها را قابل اجرا کنند.
        شما می‌توانید این هوک‌ها را درون پروژه یا در یک پروژه جداگانه توزیع کنید، اما گیت به‌طور خودکار آن‌ها را تنظیم
        نخواهد کرد.

برای شروع، شما باید پیام کامیت خود را درست قبل از اینکه هر کامیت ثبت شود بررسی کنید، بنابراین می‌دانید که سرور
        تغییرات شما را به دلیل پیام‌های کامیت بدفرمت رد نخواهد کرد.
        برای این کار، می‌توانید هوک `commit-msg` را اضافه کنید.
        اگر آن را از فایلی که به عنوان اولین آرگومان ارسال شده است بخوانید و آن را با الگو مقایسه کنید، می‌توانید گیت را
        مجبور کنید که اگر هیچ تطابقی وجود نداشته باشد، کامیت را متوقف کند:

[source,ruby]
----
#!/usr/bin/env ruby
message_file = ARGV[0]
message = File.read(message_file)

$regex = /\[ref: (\d+)\]/

if !$regex.match(message)
  puts "[سیاست] پیام شما به درستی فرمت نشده است"
  exit 1
end
----

اگر آن اسکریپت در محل (در `.git/hooks/commit-msg`) و قابل اجرا باشد و شما با پیامی که به درستی فرمت
        نشده است کامیت کنید، این را می‌بینید:

[source,console]
----
$ git commit -am 'Test'
[سیاست] پیام شما به درستی فرمت نشده است
----

در آن حالت هیچ کامیتی انجام نشد.
        با این حال، اگر پیام شما شامل الگوی مناسب باشد، گیت به شما اجازه می‌دهد که کامیت کنید:

[source,console]
----
$ git commit -am 'Test [ref: 132]'
[master e05c914] Test [ref: 132]
 1 فایل تغییر یافته، 1 درج (+)، 0 حذف (-)
----

بعد، شما می‌خواهید مطمئن شوید که فایل‌هایی را که خارج از دامنه ACL خود تغییر نمی‌دهید.
        اگر دایرکتوری `.git` پروژه شما شامل یک کپی از فایل ACL است که قبلاً استفاده کرده‌اید، سپس اسکریپت
        `pre-commit` زیر این محدودیت‌ها را برای شما تحمیل خواهد کرد:

[source,ruby]
----
#!/usr/bin/env ruby

$user    = ENV['USER']

# [ وارد کردن متد acl_access_data از بالا ]

# فقط اجازه می‌دهد کاربران خاصی زیرپوشه‌های خاصی را در یک پروژه تغییر دهند
def check_directory_perms
  access = get_acl_access_data('.git/acl')

  files_modified = `git diff-index --cached --name-only HEAD`.split("\n")
  files_modified.each do |path|
    next if path.size == 0
    has_file_access = false
    access[$user].each do |access_path|
    if !access_path || (path.index(access_path) == 0)
      has_file_access = true
    end
    if !has_file_access
      puts "[سیاست] شما به ارسال به #{path} دسترسی ندارید"
      exit 1
    end
  end
end

check_directory_perms
----

این تقریباً همان اسکریپت است که در سمت سرور وجود دارد، اما با دو تفاوت مهم.
        اولاً، فایل ACL در مکان متفاوتی است، زیرا این اسکریپت از دایرکتوری کاری شما اجرا می‌شود، نه از دایرکتوری `.git`
        شما.
        شما باید مسیر فایل ACL را از این

[source,ruby]
----
access = get_acl_access_data('acl')
----

به این تغییر دهید:

[source,ruby]
----
access = get_acl_access_data('.git/acl')
----

تفاوت مهم دیگر این است که چگونه لیستی از فایل‌هایی که تغییر کرده‌اند را به دست می‌آورید.
        زیرا روش سمت سرور به تاریخچه کامیت‌ها نگاه می‌کند و در این مرحله، کامیت هنوز ثبت نشده است، شما باید لیست
        فایل‌های خود را از ناحیه staging به دست آورید.
        به جای

[source,ruby]
----
files_modified = `git log -1 --name-only --pretty=format:'' #{ref}`
----

شما باید از این استفاده کنید:

[source,ruby]
----
files_modified = `git diff-index --cached --name-only HEAD`
----

اما این تنها دو تفاوت است – در غیر این صورت، اسکریپت به همان شیوه کار می‌کند.
        یک نکته این است که انتظار دارد شما به‌طور محلی به عنوان همان کاربری که به عنوان کاربر از راه دور ارسال می‌کنید،
        اجرا کنید.
        اگر این متفاوت باشد، باید متغیر `$user` را به‌طور دستی تنظیم کنید.

یک چیز دیگر که می‌توانیم در اینجا انجام دهیم این است که مطمئن شویم کاربر مراجع غیر پیشرفته را ارسال نمی‌کند.
        برای به دست آوردن مرجعی که پیشرفته نیست، شما یا باید از یک کامیت که قبلاً ارسال کرده‌اید، بازسازی کنید یا سعی
        کنید یک شاخه محلی متفاوت را به همان شاخه از راه دور ارسال کنید.

به احتمال زیاد، سرور قبلاً با `receive.denyDeletes` و `receive.denyNonFastForwards` برای
        تحمیل این سیاست پیکربندی شده است، بنابراین تنها چیزی که می‌توانید سعی کنید تصادفی بگیرید، بازسازی کامیت‌هایی است
        که قبلاً ارسال شده‌اند.

در اینجا یک اسکریپت `pre-rebase` نمونه وجود دارد که برای این کار بررسی می‌کند.
        این لیستی از تمام کامیت‌هایی که در حال بازنویسی هستید را به دست می‌آورد و بررسی می‌کند که آیا آن‌ها در هر یک از
        مراجع راه دور شما وجود دارند یا خیر.
        اگر ببیند که یکی از آن‌ها از یکی از مراجع راه دور قابل دسترسی است، بازسازی را متوقف می‌کند.

[source,ruby]
----
#!/usr/bin/env ruby

base_branch = ARGV[0]
if ARGV[1]
  topic_branch = ARGV[1]
else
  topic_branch = "HEAD"
end

target_shas = `git rev-list #{base_branch}..#{topic_branch}`.split("\n")
remote_refs = `git branch -r`.split("\n").map { |r| r.strip }

target_shas.each do |sha|
  remote_refs.each do |remote_ref|
    shas_pushed = `git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
    if shas_pushed.split("\n").include?(sha)
      puts "[سیاست] کامیت #{sha} قبلاً به #{remote_ref} ارسال شده است"
      exit 1
    end
  end
end
----

این اسکریپت از یک سینتکس استفاده می‌کند که در <<_revision_selection#_revision_selection>> پوشش داده نشده است.
        شما با اجرای این:

[source,ruby]
----
`git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
----

لیستی از کامیت‌هایی که قبلاً ارسال شده‌اند به دست می‌آورید.
        سینتکس `SHA^@` به تمام والدین آن کامیت اشاره می‌کند.
        شما به دنبال هر کامیتی هستید که از آخرین کامیت در راه دور قابل دسترسی باشد و از هیچ والدینی از هر یک از
        SHA-1هایی که در حال تلاش برای ارسال هستید، قابل دسترسی نباشد – به این معنی که پیشرفته است.

معایب اصلی این رویکرد این است که می‌تواند بسیار کند باشد و اغلب غیرضروری است – اگر شما سعی نکنید با
        `-f` ارسال اجباری کنید، سرور به شما هشدار می‌دهد و ارسال را قبول نمی‌کند.
        با این حال، این یک تمرین جالب است و می‌تواند به‌طور نظری به شما کمک کند تا از یک بازسازی که ممکن است بعداً مجبور
        به اصلاح آن شوید، جلوگیری کنید.
