=== ویژگی‌های گیت

(((attributes)))
برخی از این تنظیمات همچنین می‌توانند برای یک مسیر مشخص شوند، به طوری که گیت این تنظیمات را فقط برای یک زیرپوشه یا
      زیرمجموعه‌ای از فایل‌ها اعمال کند.
      این تنظیمات خاص مسیر به نام ویژگی‌های گیت شناخته می‌شوند و در یک فایل `.gitattributes` در یکی از
      دایرکتوری‌های شما (معمولاً ریشه پروژه شما) یا در فایل `.git/info/attributes` تنظیم می‌شوند اگر
      نمی‌خواهید فایل ویژگی‌ها با پروژه شما کامیت شود.

با استفاده از ویژگی‌ها، می‌توانید کارهایی مانند مشخص کردن استراتژی‌های ادغام جداگانه برای فایل‌ها یا
      دایرکتوری‌های خاص در پروژه خود، به گیت بگویید که چگونه فایل‌های غیرمتنی را مقایسه کند، یا از گیت بخواهید که محتوا
      را قبل از اینکه آن را به گیت اضافه کنید یا از آن خارج کنید، فیلتر کند.
      در این بخش، شما با برخی از ویژگی‌هایی که می‌توانید بر روی مسیرهای خود در پروژه گیت خود تنظیم کنید آشنا خواهید شد و
      چند مثال از استفاده از این ویژگی در عمل را خواهید دید.

==== فایل‌های باینری

(((binary files)))
یکی از ترفندهای جالبی که می‌توانید با استفاده از ویژگی‌های گیت انجام دهید، این است که به گیت بگویید کدام فایل‌ها
        باینری هستند (در مواردی که ممکن است نتواند تشخیص دهد) و به گیت دستورالعمل‌های خاصی درباره نحوه مدیریت آن فایل‌ها
        بدهید.
        به عنوان مثال، برخی از فایل‌های متنی ممکن است به صورت ماشینی تولید شده و قابل مقایسه نباشند، در حالی که برخی از
        فایل‌های باینری می‌توانند مقایسه شوند.
        شما خواهید دید که چگونه به گیت بگویید کدام یک کدام است.

===== شناسایی فایل‌های باینری

برخی از فایل‌ها به نظر می‌رسند که فایل‌های متنی هستند اما به هر دلیلی باید به عنوان داده‌های باینری در نظر
          گرفته شوند.
          به عنوان مثال، پروژه‌های Xcode در macOS شامل فایلی هستند که با `.pbxproj` پایان می‌یابد، که اساساً
          یک مجموعه داده JSON (فرمت داده‌های جاوا اسکریپت متنی) است که توسط IDE به دیسک نوشته شده و تنظیمات ساخت شما و
          غیره را ثبت می‌کند.
          اگرچه این فایل به طور فنی یک فایل متنی است (زیرا همه چیز UTF-8 است)، اما نمی‌خواهید آن را به عنوان چنین در نظر
          بگیرید زیرا در واقع یک پایگاه داده سبک است – شما نمی‌توانید محتویات آن را ادغام کنید اگر دو نفر آن را تغییر
          کنند و مقایسه‌ها معمولاً مفید نیستند.
          این فایل به منظور مصرف توسط یک ماشین طراحی شده است.
          در واقع، شما می‌خواهید آن را مانند یک فایل باینری در نظر بگیرید.

برای اینکه به گیت بگویید که تمام فایل‌های `pbxproj` را به عنوان داده‌های باینری در نظر بگیرد، خط
          زیر را به فایل `.gitattributes` خود اضافه کنید:

[source,ini]
----
*.pbxproj binary
----

اکنون، گیت سعی نخواهد کرد که مشکلات CRLF را تبدیل یا اصلاح کند؛ همچنین سعی نخواهد کرد که تفاوت‌ها را برای
          تغییرات در این فایل محاسبه یا چاپ کند زمانی که شما `git show` یا `git diff` را در پروژه
          خود اجرا می‌کنید.

===== مقایسه فایل‌های باینری

شما همچنین می‌توانید از قابلیت ویژگی‌های گیت برای مقایسه مؤثر فایل‌های باینری استفاده کنید.
          شما این کار را با گفتن به گیت انجام می‌دهید که چگونه داده‌های باینری خود را به یک فرمت متنی تبدیل کند که بتوان
          آن را از طریق مقایسه عادی مقایسه کرد.

اول، شما از این تکنیک برای حل یکی از آزاردهنده‌ترین مشکلات شناخته شده برای بشریت استفاده خواهید کرد: کنترل
          نسخه اسناد Microsoft Word.
          همه می‌دانند که Word بدترین ویرایشگر است، اما به طرز عجیبی، همه هنوز از آن استفاده می‌کنند.
          اگر می‌خواهید اسناد Word را کنترل نسخه کنید، می‌توانید آن‌ها را در یک مخزن گیت قرار دهید و هر از گاهی کامیت
          کنید؛ اما این چه فایده‌ای دارد؟
          اگر شما به طور معمول `git diff` را اجرا کنید، فقط چیزی شبیه به این را خواهید دید:

[source,console]
----
$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 88839c4..4afcb7c 100644
Binary files a/chapter1.docx and b/chapter1.docx differ
----

شما نمی‌توانید دو نسخه را به طور مستقیم مقایسه کنید مگر اینکه آن‌ها را بررسی کنید و به صورت دستی اسکن کنید،
          درست است؟
          به نظر می‌رسد که می‌توانید این کار را به خوبی با استفاده از ویژگی‌های گیت انجام دهید.
          خط زیر را در فایل `.gitattributes` خود قرار دهید:

[source,ini]
----
*.docx diff=word
----

این به گیت می‌گوید که هر فایلی که با این الگو مطابقت دارد (`.docx`) باید از فیلتر "word" استفاده
          کند زمانی که شما سعی می‌کنید تفاوت‌هایی را مشاهده کنید که شامل تغییرات است.
          فیلتر "word" چیست؟
          شما باید آن را تنظیم کنید.
          در اینجا شما گیت را پیکربندی می‌کنید تا از برنامه `docx2txt` برای تبدیل اسناد Word به فایل‌های متنی
          قابل خواندن استفاده کند، که سپس به درستی مقایسه می‌شوند.

اول، شما باید `docx2txt` را نصب کنید؛ می‌توانید آن را از https://sourceforge.net/projects/docx2txt[]دانلود کنید.
          دستورالعمل‌های موجود در فایل `INSTALL` را دنبال کنید تا آن را در جایی قرار دهید که شل شما بتواند آن
          را پیدا کند.
          سپس، شما یک اسکریپت wrapper برای تبدیل خروجی به فرمت مورد انتظار گیت خواهید نوشت.
          فایلی که در مسیر شما قرار دارد به نام `docx2txt` ایجاد کنید و این محتویات را اضافه کنید:

[source,console]
----
#!/bin/bash
docx2txt.pl "$1" -
----

فراموش نکنید که به آن فایل `chmod a+x` بدهید.
          در نهایت، می‌توانید گیت را پیکربندی کنید تا از این اسکریپت استفاده کند:

[source,console]
----
$ git config diff.word.textconv docx2txt
----

اکنون گیت می‌داند که اگر سعی کند تفاوتی بین دو snapshot انجام دهد و هر یک از فایل‌ها با `.docx`
          پایان یابد، باید آن فایل‌ها را از طریق فیلتر "word" که به عنوان برنامه `docx2txt` تعریف شده است،
          اجرا کند.
          این به طور مؤثری نسخه‌های متنی خوبی از فایل‌های Word شما را قبل از تلاش برای مقایسه آن‌ها ایجاد می‌کند.

در اینجا یک مثال است: فصل 1 این کتاب به فرمت Word تبدیل شده و در یک مخزن گیت کامیت شده است.
          سپس یک پاراگراف جدید اضافه شده است.
          این است که `git diff` نشان می‌دهد:

[source,console]
----
$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 0b013ca..ba25db5 100644
--- a/chapter1.docx
+++ b/chapter1.docx
@@ -2,6 +2,7 @@
 این فصل درباره شروع به کار با گیت خواهد بود. ما با توضیح برخی از زمینه‌ها در مورد ابزارهای کنترل نسخه شروع خواهیم کرد، سپس به نحوه راه‌اندازی گیت در سیستم شما و در نهایت نحوه تنظیم آن برای شروع کار خواهیم پرداخت. در پایان این فصل شما باید درک کنید که چرا گیت وجود دارد، چرا باید از آن استفاده کنید و باید به طور کامل آماده باشید تا این کار را انجام دهید.
 1.1. درباره کنترل نسخه
 کنترل نسخه چیست و چرا باید به آن اهمیت دهید؟ کنترل نسخه سیستمی است که تغییرات را در یک فایل یا مجموعه‌ای از فایل‌ها در طول زمان ثبت می‌کند تا بتوانید نسخه‌های خاصی را بعداً به یاد بیاورید. برای مثال‌ها در این کتاب، شما از کد منبع نرم‌افزار به عنوان فایل‌های تحت کنترل نسخه استفاده خواهید کرد، اگرچه در واقع می‌توانید این کار را با تقریباً هر نوع فایلی در یک کامپیوتر انجام دهید.
+آزمایش: 1، 2، 3.
 اگر شما یک طراح گرافیک یا وب هستید و می‌خواهید هر نسخه از یک تصویر یا طرح را نگه دارید (که قطعاً می‌خواهید)، استفاده از یک سیستم کنترل نسخه (VCS) بسیار عاقلانه است. این به شما اجازه می‌دهد تا فایل‌ها را به حالت قبلی برگردانید، کل پروژه را به حالت قبلی برگردانید، تغییرات را در طول زمان مقایسه کنید، ببینید چه کسی آخرین بار چیزی را تغییر داده که ممکن است باعث ایجاد مشکل شود، چه کسی یک مشکل را معرفی کرده و چه زمانی، و بیشتر. استفاده از یک VCS همچنین به طور کلی به این معنی است که اگر چیزها را خراب کنید یا فایل‌ها را گم کنید، می‌توانید به راحتی آن‌ها را بازیابی کنید. علاوه بر این، شما تمام این‌ها را با هزینه بسیار کمی دریافت می‌کنید.
 1.1.1. سیستم‌های کنترل نسخه محلی
 روش کنترل نسخه انتخابی بسیاری از مردم این است که فایل‌ها را به یک دایرکتوری دیگر کپی کنند (شاید یک دایرکتوری با زمان‌مهر، اگر آن‌ها باهوش باشند). این رویکرد بسیار رایج است زیرا بسیار ساده است، اما همچنین به شدت مستعد خطاست. به راحتی می‌توان فراموش کرد که در کدام دایرکتوری هستید و به طور تصادفی به فایل اشتباهی بنویسید یا فایل‌هایی را که نمی‌خواهید کپی کنید.
----

گیت به طور موفقیت‌آمیز و مختصر به ما می‌گوید که رشته "آزمایش: 1، 2، 3." را اضافه کرده‌ایم، که درست است.
          این کامل نیست – تغییرات فرمت در اینجا نشان داده نمی‌شوند – اما قطعاً کار می‌کند.

یک مشکل جالب دیگر که می‌توانید اینگونه حل کنید، مقایسه فایل‌های تصویری است.
          یک راه برای انجام این کار این است که فایل‌های تصویری را از طریق یک فیلتر که اطلاعات EXIF آن‌ها را استخراج
          می‌کند، اجرا کنید – متاداده‌ای که با اکثر فرمت‌های تصویری ثبت می‌شود.
          اگر شما برنامه `exiftool` را دانلود و نصب کنید، می‌توانید از آن برای تبدیل تصاویر خود به متن درباره
          متاداده استفاده کنید، بنابراین حداقل تفاوت‌ها نمایشی متنی از هر تغییری که اتفاق افتاده است را نشان می‌دهد.
          خط زیر را در فایل `.gitattributes` خود قرار دهید:

[source,ini]
----
*.png diff=exif
----

گیت را پیکربندی کنید تا از این ابزار استفاده کند:

[source,console]
----
$ git config diff.exif.textconv exiftool
----

اگر شما یک تصویر را در پروژه خود جایگزین کنید و `git diff` را اجرا کنید، چیزی شبیه به این را
          خواهید دید:

[source,diff]
----
diff --git a/image.png b/image.png
index 88839c4..4afcb7c 100644
--- a/image.png
+++ b/image.png
@@ -1,12 +1,12 @@
 ExifTool Version Number         : 7.74
-File Size                       : 70 kB
-File Modification Date/Time     : 2009:04:21 07:02:45-07:00
+File Size                       : 94 kB
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
 File Type                       : PNG
 MIME Type                       : image/png
-Image Width                     : 1058
-Image Height                    : 889
+Image Width                     : 1056
+Image Height                    : 827
 Bit Depth                       : 8
 Color Type                      : RGB with Alpha
----

شما به راحتی می‌توانید ببینید که اندازه فایل و ابعاد تصویر هر دو تغییر کرده‌اند.

[[_keyword_expansion]]
==== گسترش کلیدواژه

(((keyword expansion)))
گسترش کلیدواژه به سبک SVN یا CVS اغلب توسط توسعه‌دهندگانی که به آن سیستم‌ها عادت دارند درخواست می‌شود.
        مشکل اصلی با این در گیت این است که شما نمی‌توانید فایلی را با اطلاعات مربوط به کامیت پس از اینکه کامیت کرده‌اید،
        تغییر دهید، زیرا گیت ابتدا checksum فایل را بررسی می‌کند.
        با این حال، شما می‌توانید متن را هنگام چک‌اوت به یک فایل تزریق کنید و قبل از اینکه دوباره به یک کامیت اضافه شود،
        آن را حذف کنید.
        ویژگی‌های گیت به شما دو روش برای انجام این کار ارائه می‌دهد.

اول، شما می‌توانید checksum SHA-1 یک blob را به یک فیلد `$Id$` در فایل به طور خودکار تزریق کنید.
        اگر این ویژگی را بر روی یک فایل یا مجموعه‌ای از فایل‌ها تنظیم کنید، سپس دفعه بعد که این شاخه را چک‌اوت کنید، گیت
        آن فیلد را با SHA-1 blob جایگزین می‌کند.
        مهم است که توجه داشته باشید که این SHA-1 مربوط به کامیت نیست، بلکه مربوط به خود blob است.
        خط زیر را در فایل `.gitattributes` خود قرار دهید:

[source,ini]
----
*.txt ident
----

یک مرجع `$Id$` به یک فایل آزمایشی اضافه کنید:

[source,console]
----
$ echo '$Id$' > test.txt
----

دفعه بعد که این فایل را چک‌اوت کنید، گیت SHA-1 blob را تزریق می‌کند:

[source,console]
----
$ rm test.txt
$ git checkout -- test.txt
$ cat test.txt
$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $
----

با این حال، آن نتیجه استفاده محدودی دارد.
        اگر شما از جایگزینی کلیدواژه در CVS یا Subversion استفاده کرده‌اید، می‌توانید یک تاریخ‌مهر را شامل شوید – SHA-1
        چندان مفید نیست، زیرا نسبتاً تصادفی است و شما نمی‌توانید بگویید که آیا یک SHA-1 قدیمی‌تر یا جدیدتر از دیگری است
        فقط با نگاه کردن به آن‌ها.

به نظر می‌رسد که شما می‌توانید فیلترهای خود را برای انجام جایگزینی در فایل‌ها در زمان کامیت/چک‌اوت بنویسید.
        این‌ها به عنوان فیلترهای "clean" و "smudge" شناخته می‌شوند.
        در فایل `.gitattributes`، می‌توانید یک فیلتر برای مسیرهای خاص تنظیم کنید و سپس اسکریپت‌هایی را تنظیم
        کنید که فایل‌ها را درست قبل از اینکه چک‌اوت شوند ("smudge"، ببینید <<filters_a#filters_a>>) و درست قبل از اینکه آن‌ها به حالت staging بروند ("clean"،
        ببینید <<filters_b#filters_b>>).
        این فیلترها می‌توانند کارهای جالبی انجام دهند.

[[filters_a]]
.فیلتر "smudge" در زمان چک‌اوت اجرا می‌شود.
image::images/smudge.png[فیلتر "smudge" در زمان چک‌اوت اجرا می‌شود.]

[[filters_b]]
.فیلتر "clean" در زمان staging اجرا می‌شود.
image::images/clean.png[فیلتر "clean" در زمان staging اجرا می‌شود.]

پیام کامیت اصلی برای این ویژگی یک مثال ساده از اجرای تمام کدهای منبع C از طریق برنامه `indent` قبل
        از کامیت را ارائه می‌دهد.
        شما می‌توانید این را با تنظیم ویژگی فیلتر در فایل `.gitattributes` برای فیلتر `*.c` با
        فیلتر "indent" تنظیم کنید:

[source,ini]
----
*.c filter=indent
----

سپس، به گیت بگویید که فیلتر "indent" چه کاری در زمان smudge و clean انجام می‌دهد:

[source,console]
----
$ git config --global filter.indent.clean indent
$ git config --global filter.indent.smudge cat
----

در این حالت، زمانی که شما فایل‌هایی که با `*.c` مطابقت دارند را کامیت می‌کنید، گیت آن‌ها را قبل از
        اینکه به حالت staging بروند از طریق برنامه indent اجرا می‌کند و سپس قبل از اینکه دوباره به دیسک چک‌اوت شوند، از
        طریق برنامه `cat` اجرا می‌کند.
        برنامه `cat` اساساً هیچ کاری انجام نمی‌دهد: فقط داده‌هایی را که وارد می‌شود، بازمی‌گرداند.
        این ترکیب به طور مؤثر تمام فایل‌های کد منبع C را قبل از کامیت از طریق `indent` فیلتر می‌کند.

یک مثال جالب دیگر گسترش کلیدواژه `$Date$` به سبک RCS است.
        برای انجام این کار به درستی، شما به یک اسکریپت کوچک نیاز دارید که نام فایل را بگیرد، آخرین تاریخ کامیت برای این
        پروژه را پیدا کند و تاریخ را در آن فایل وارد کند.
        در اینجا یک اسکریپت کوچک روبی وجود دارد که این کار را انجام می‌دهد:

[source,ruby]
----
#! /usr/bin/env ruby
data = STDIN.read
last_date = `git log --pretty=format:"%ad" -1`
puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')
----

تمام کاری که این اسکریپت انجام می‌دهد این است که آخرین تاریخ کامیت را از دستور `git log` دریافت
        کرده، آن را به هر رشته `$Date$` که در stdin می‌بیند، اضافه کرده و نتایج را چاپ می‌کند – باید ساده
        باشد که این کار را در هر زبانی که با آن راحت‌تر هستید انجام دهید.
        شما می‌توانید این فایل را `expand_date` نام‌گذاری کرده و در مسیر خود قرار دهید.
        اکنون، شما باید یک فیلتر در گیت تنظیم کنید (آن را `dater` نام‌گذاری کنید) و به آن بگویید که از فیلتر
        `expand_date` شما برای smudge کردن فایل‌ها در زمان چک‌اوت استفاده کند.
        شما از یک عبارت Perl برای تمیز کردن آن در زمان کامیت استفاده خواهید کرد:

[source,console]
----
$ git config filter.dater.smudge expand_date
$ git config filter.dater.clean 'perl -pe "s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/"'
----

این قطعه Perl هر چیزی را که در یک رشته `$Date$` می‌بیند، حذف می‌کند تا به جایی که شروع کردید،
        برگردد.
        اکنون که فیلتر شما آماده است، می‌توانید آن را با تنظیم یک ویژگی گیت برای آن فایل که فیلتر جدید را فعال می‌کند و
        ایجاد یک فایل با کلیدواژه `$Date$` آزمایش کنید:

[source,ini]
----
date*.txt filter=dater
----

[source,console]
----
$ echo '# $Date$' > date_test.txt
----

اگر شما آن تغییرات را کامیت کنید و دوباره فایل را چک‌اوت کنید، می‌بینید که کلیدواژه به درستی جایگزین شده
        است:

[source,console]
----
$ git add date_test.txt .gitattributes
$ git commit -m "آزمایش گسترش تاریخ در گیت"
$ rm date_test.txt
$ git checkout date_test.txt
$ cat date_test.txt
# $Date: Tue Apr 21 07:26:52 2009 -0700$
----

شما می‌توانید ببینید که این تکنیک چقدر برای برنامه‌های سفارشی قدرتمند است.
        با این حال، شما باید مراقب باشید، زیرا فایل `.gitattributes` کامیت شده و با پروژه منتقل می‌شود، اما
        درایور (در این مورد، `dater`) نیست، بنابراین در همه جا کار نخواهد کرد.
        زمانی که شما این فیلترها را طراحی می‌کنید، باید بتوانند به آرامی شکست بخورند و پروژه هنوز به درستی کار کند.

==== صادرات مخزن شما

(((archiving)))
داده‌های ویژگی‌های گیت همچنین به شما اجازه می‌دهد تا کارهای جالبی هنگام صادرات یک آرشیو از پروژه خود انجام
        دهید.

===== `export-ignore`

شما می‌توانید به گیت بگویید که هنگام تولید یک آرشیو، برخی از فایل‌ها یا دایرکتوری‌ها را صادر نکند.
          اگر یک زیرپوشه یا فایلی وجود داشته باشد که نمی‌خواهید در فایل آرشیو شما گنجانده شود اما می‌خواهید آن را در
          پروژه خود چک کنید، می‌توانید آن فایل‌ها را از طریق ویژگی `export-ignore` تعیین کنید.

به عنوان مثال، فرض کنید شما برخی از فایل‌های آزمایشی در یک زیرپوشه `test/` دارید و منطقی نیست که
          آن‌ها را در صادرات tarball پروژه خود گنجانده شود.
          شما می‌توانید خط زیر را به فایل ویژگی‌های گیت خود اضافه کنید:

[source,ini]
----
test/ export-ignore
----

اکنون، زمانی که شما `git archive` را اجرا می‌کنید تا یک tarball از پروژه خود ایجاد کنید، آن
          دایرکتوری در آرشیو گنجانده نخواهد شد.

===== `export-subst`

هنگام صادرات فایل‌ها برای استقرار، می‌توانید پردازش فرمت‌دهی و گسترش کلیدواژه‌های `git log` را به
          بخش‌های انتخاب شده از فایل‌ها که با ویژگی `export-subst` علامت‌گذاری شده‌اند، اعمال کنید.

به عنوان مثال، اگر می‌خواهید فایلی به نام `LAST_COMMIT` را در پروژه خود شامل کنید و اطلاعات
          متاداده درباره آخرین کامیت به طور خودکار در آن وارد شود زمانی که `git archive` اجرا می‌شود،
          می‌توانید به عنوان مثال فایل‌های `.gitattributes` و `LAST_COMMIT` خود را به این صورت
          تنظیم کنید:

[source,ini]
----
LAST_COMMIT export-subst
----

[source,console]
----
$ echo 'تاریخ آخرین کامیت: $Format:%cd by %aN$' > LAST_COMMIT
$ git add LAST_COMMIT .gitattributes
$ git commit -am 'اضافه کردن فایل LAST_COMMIT برای آرشیوها'
----

زمانی که شما `git archive` را اجرا می‌کنید، محتوای فایل آرشیو به این صورت خواهد بود:

[source,console]
----
$ git archive HEAD | tar xCf ../deployment-testing -
$ cat ../deployment-testing/LAST_COMMIT
تاریخ آخرین کامیت: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon
----

جایگزینی‌ها می‌توانند شامل به عنوان مثال پیام کامیت و هر `git notes` باشند و `git log`
          می‌تواند کارهای ساده‌ای مانند خط‌پیچی را انجام دهد:

[source,console]
----
$ echo '$Format:آخرین کامیت: %h by %aN at %cd%n%+w(76,6,9)%B$' > LAST_COMMIT
$ git commit -am 'export-subst از فرمت‌دهی سفارشی git log استفاده می‌کند'

git archive از پردازشگر pretty=format: git log به طور مستقیم استفاده می‌کند
و علامت‌گذاری محاطی $Format: و $
را از خروجی حذف می‌کند.
'
$ git archive @ | tar xfO - LAST_COMMIT
آخرین کامیت: 312ccc8 by Jim Hill at Fri May 8 09:14:04 2015 -0700
       export-subst از پردازشگر فرمت‌دهی git log به طور مستقیم استفاده می‌کند
و علامت‌گذاری محاطی $Format: و $
را از خروجی حذف می‌کند.
----

آرشیو حاصل برای کارهای استقرار مناسب است، اما مانند هر آرشیو صادراتی برای کارهای توسعه‌ای مناسب نیست.

==== استراتژی‌های ادغام

(((merging, strategies)))
شما همچنین می‌توانید از ویژگی‌های گیت برای گفتن به گیت استفاده کنید که از استراتژی‌های ادغام مختلف برای فایل‌های
        خاص در پروژه شما استفاده کند.
        یکی از گزینه‌های بسیار مفید این است که به گیت بگویید که در صورت بروز تضاد، سعی نکند فایل‌های خاصی را ادغام کند،
        بلکه از طرف شما در ادغام استفاده کند.

این مفید است اگر یک شاخه در پروژه شما انحراف داشته باشد یا تخصصی باشد، اما می‌خواهید بتوانید تغییرات را از آن
        ادغام کنید و می‌خواهید برخی از فایل‌ها را نادیده بگیرید.
        فرض کنید شما یک فایل تنظیمات پایگاه داده به نام `database.xml` دارید که در دو شاخه متفاوت است و
        می‌خواهید تغییرات را از شاخه دیگر ادغام کنید بدون اینکه فایل پایگاه داده را خراب کنید.
        شما می‌توانید ویژگی‌ای مانند این را تنظیم کنید:

[source,ini]
----
database.xml merge=ours
----

و سپس یک استراتژی ادغام جعلی `ours` را با:

[source,console]
----
$ git config --global merge.ours.driver true
----

اگر شما تغییرات را از شاخه دیگر ادغام کنید، به جای اینکه تضادهای ادغامی با فایل `database.xml` داشته
        باشید، چیزی شبیه به این را خواهید دید:

[source,console]
----
$ git merge topic
Auto-merging database.xml
Merge made by recursive.
----

در این حالت، `database.xml` در هر نسخه‌ای که شما در ابتدا داشتید باقی می‌ماند.
