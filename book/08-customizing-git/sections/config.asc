[[_git_config]]
=== پیکربندی گیت

(((git commands, config)))
همانطور که به طور مختصر در <<ch01-getting-started#ch01-getting-started>>
      خواندید، می‌توانید تنظیمات پیکربندی گیت را با دستور `git config` مشخص کنیدپیدا کنید.
      یکی از اولین کارهایی که انجام دادید، تنظیم نام و آدرس ایمیل شما بود:

[source,console]
----
$ git config --global user.name "جان دو"
$ git config --global user.email johndoe@example.com
----

اکنون چند گزینه جالب‌تر را یاد خواهید گرفت که می‌توانید به این روش برای سفارشی‌سازی استفاده از گیت تنظیم
      کنید.

اول، یک مرور سریع: گیت از مجموعه‌ای از فایل‌های پیکربندی برای تعیین رفتار غیر پیش‌فرضی که ممکن است بخواهید
      استفاده می‌کند.
      اولین جایی که گیت به دنبال این مقادیر می‌گردد، فایل پیکربندی سیستم‌گسترده `/etc/gitconfig` است که شامل
      تنظیماتی است که به هر کاربر در سیستم و تمام مخازن آن‌ها اعمال می‌شود.
      اگر گزینه `--system` را به `git config` بدهید، به طور خاص از این فایل خوانده و نوشته می‌شود.

جای بعدی که گیت به دنبال آن می‌گردد، فایل `~/.gitconfig` (یا `~/.config/git/config`) است که
      مختص هر کاربر است.
      می‌توانید با دادن گزینه `--global` به گیت بگویید که از این فایل بخواند و بنویسد.

در نهایت، گیت به دنبال مقادیر پیکربندی در فایل پیکربندی در دایرکتوری گیت (`.git/config`) از هر مخزنی
      که در حال حاضر استفاده می‌کنید، می‌گردد.
      این مقادیر مختص آن مخزن خاص هستند و نمایانگر دادن گزینه `--local` به `git config` هستند.
      (اگر مشخص نکنید که می‌خواهید با کدام سطح کار کنید، این پیش‌فرض است.)

هر یک از این "سطوح" (سیستم، جهانی، محلی) مقادیر سطح قبلی را بازنویسی می‌کند، بنابراین مقادیر در
      `.git/config` بر مقادیر در `/etc/gitconfig` ارجحیت دارند، به عنوان مثال.

[NOTE]
====
فایل‌های پیکربندی گیت متن‌ساده هستند، بنابراین می‌توانید این مقادیر را با ویرایش دستی فایل و وارد کردن
              نحو صحیح نیز تنظیم کنید.
              با این حال، معمولاً راحت‌تر است که دستور `git config` را اجرا کنید.
====

==== پیکربندی پایه کلاینت

گزینه‌های پیکربندی که گیت شناسایی می‌کند به دو دسته تقسیم می‌شوند: سمت کلاینت و سمت سرور.
        اکثر گزینه‌ها سمت کلاینت هستند -- تنظیم ترجیحات کاری شخصی شما.
        بسیاری، _بسیاری_ از گزینه‌های پیکربندی پشتیبانی می‌شوند، اما بخش بزرگی از آن‌ها فقط در موارد خاص مفید
        هستند؛ ما فقط رایج‌ترین و مفیدترین گزینه‌ها را در اینجا پوشش خواهیم داد.
        اگر می‌خواهید فهرستی از تمام گزینه‌هایی که نسخه شما از گیت شناسایی می‌کند را ببینید، می‌توانید این دستور را اجرا
        کنید:

[source,console]
----
$ man git-config
----

این دستور تمام گزینه‌های موجود را با جزئیات کافی فهرست می‌کند.
        شما همچنین می‌توانید این مطالب مرجع را در https://git-scm.com/docs/git-config[].

===== `core.editor`

((($EDITOR)))((($VISUAL, see $EDITOR)))
به طور پیش‌فرض، گیت از هر چیزی که به عنوان ویرایشگر متن پیش‌فرض خود از طریق یکی از متغیرهای محیطی شل `VISUAL`
          یا `EDITOR` تنظیم کرده‌اید، استفاده می‌کند، و در غیر این صورت به ویرایشگر `vi` برای
          ایجاد و ویرایش پیام‌های کامیت و برچسب‌ها بازمی‌گردد.
          برای تغییر این پیش‌فرض به چیز دیگری، می‌توانید از تنظیم `core.editor` استفاده کنید:

[source,console]
----
$ git config --global core.editor emacs
----

اکنون، مهم نیست که چه چیزی به عنوان ویرایشگر شل پیش‌فرض شما تنظیم شده باشد، گیت برای ویرایش پیام‌ها، Emacs را
          باز می‌کند.

===== `commit.template`

(((commit templates)))
اگر این را به مسیر یک فایل در سیستم خود تنظیم کنید، گیت از آن فایل به عنوان پیام اولیه پیش‌فرض هنگام کامیت
          استفاده خواهد کرد.
          ارزش ایجاد یک الگوی کامیت سفارشی این است که می‌توانید از آن برای یادآوری خود (یا دیگران) در مورد فرمت و سبک
          مناسب هنگام ایجاد یک پیام کامیت استفاده کنید.

به عنوان مثال، یک فایل الگو در `~/.gitmessage.txt` که به این شکل باشد:

[source,text]
----
خط موضوع (سعی کنید زیر 50 کاراکتر نگه دارید)

توضیحات چند خطی از کامیت،
احساس راحتی کنید که جزئیات بیشتری اضافه کنید.

[تیکت: X]
----

به یاد داشته باشید که این الگوی کامیت به کامیت‌کننده یادآوری می‌کند که خط موضوع را کوتاه نگه دارد (برای خروجی
          `git log --oneline`)، جزئیات بیشتری زیر آن اضافه کند و اگر تیکتی وجود دارد، به شماره تیکت یا ردیاب
          اشکال اشاره کند.

برای اینکه به گیت بگویید از آن به عنوان پیام پیش‌فرضی که هنگام اجرای `git commit` در ویرایشگر شما
          ظاهر می‌شود استفاده کند، مقدار پیکربندی `commit.template` را تنظیم کنید:

[source,console]
----
$ git config --global commit.template ~/.gitmessage.txt
$ git commit
----

سپس، ویرایشگر شما برای پیام کامیت جایگزین شما به چیزی شبیه به این باز خواهد شد:

[source,text]
----
خط موضوع (سعی کنید زیر 50 کاراکتر نگه دارید)

توضیحات چند خطی از کامیت،
احساس راحتی کنید که جزئیات بیشتری اضافه کنید.

[تیکت: X]
# لطفاً پیام کامیت خود را برای تغییرات خود وارد کنید. خطوطی که با
# '#' شروع می‌شوند نادیده گرفته می‌شوند و یک پیام خالی کامیت را لغو می‌کند.
# در شاخه master
# تغییرات برای کامیت:
#   (از "git reset HEAD <file>..." برای لغو انتخاب استفاده کنید)
#
# تغییر یافته:   lib/test.rb
#
~
~
".git/COMMIT_EDITMSG" 14L, 297C
----

اگر تیم شما یک سیاست پیام کامیت دارد، قرار دادن یک الگو برای آن سیاست در سیستم شما و پیکربندی گیت برای
          استفاده از آن به طور پیش‌فرض می‌تواند به افزایش احتمال پیروی از آن سیاست کمک کند.

===== `core.pager`

(((pager)))
این تنظیم تعیین می‌کند که کدام صفحه‌گردان هنگام خروجی گیت مانند `log` و `diff` استفاده
          می‌شود.
          می‌توانید آن را به `more` یا به صفحه‌گردان مورد علاقه خود (به طور پیش‌فرض، `less`) تنظیم
          کنید، یا می‌توانید با تنظیم آن به یک رشته خالی آن را خاموش کنید:

[source,console]
----
$ git config --global core.pager ''
----

اگر این کار را انجام دهید، گیت تمام خروجی تمام دستورات را صفحه‌بندی می‌کند، مهم نیست که چقدر طولانی
          هستند.

===== `user.signingkey`

(((GPG)))
اگر شما برچسب‌های امضا شده و حاشیه‌نویسی شده ایجاد می‌کنید (همانطور که در <<_signing#_signing>> بحث شده است)، تنظیم کلید امضای GPG شما به عنوان یک تنظیم پیکربندی کار را آسان‌تر
          می‌کند.
          کلید ID خود را به این شکل تنظیم کنید:

[source,console]
----
$ git config --global user.signingkey <gpg-key-id>
----

اکنون، می‌توانید برچسب‌ها را بدون نیاز به مشخص کردن کلید خود هر بار با دستور `git tag` امضا کنید:

[source,console]
----
$ git tag -s <tag-name>
----

===== `core.excludesfile`

(((excludes)))(((.gitignore)))
می‌توانید الگوهایی را در فایل `.gitignore` پروژه خود قرار دهید تا گیت آن‌ها را به عنوان فایل‌های
          بدون ردیابی نبیند یا سعی نکند آن‌ها را هنگام اجرای `git add` بر روی آن‌ها انتخاب کند، همانطور که در
          <<_ignoring#_ignoring>> بحث شده است.

اما گاهی اوقات می‌خواهید برخی از فایل‌ها را برای تمام مخازن که با آن‌ها کار می‌کنید نادیده بگیرید.
          اگر کامپیوتر شما در حال اجرای macOS است، احتمالاً با فایل‌های `.DS_Store` آشنا هستید.
          اگر ویرایشگر مورد علاقه شما Emacs یا Vim است، درباره نام فایل‌هایی که با `~` یا `.swp`
          پایان می‌یابند، می‌دانید.

این تنظیم به شما اجازه می‌دهد نوعی فایل `.gitignore` جهانی بنویسید.
          اگر یک فایل `~/.gitignore_global` با این محتویات ایجاد کنید:

[source,ini]
----
*~
.*.swp
.DS_Store
----

…و دستور `git config --global core.excludesfile ~/.gitignore_global` را اجرا کنید، گیت دیگر هرگز
          شما را در مورد آن فایل‌ها آزار نخواهد داد.

===== `help.autocorrect`

(((autocorrect)))
اگر یک دستور را اشتباه تایپ کنید، چیزی شبیه به این به شما نشان می‌دهد:

[source,console]
----
$ git chekcout master
git: 'chekcout' is not a git command. See 'git --help'.

آیا منظور شما این بود؟
    checkout
----

گیت به طور مفید سعی می‌کند بفهمد که منظور شما چه بوده، اما هنوز هم از انجام آن امتناع می‌کند.
          اگر `help.autocorrect` را به 1 تنظیم کنید، گیت واقعاً این دستور را برای شما اجرا خواهد کرد:

[source,console]
----
$ git chekcout master
WARNING: You called a Git command named 'chekcout', which does not exist.
Continuing under the assumption that you meant 'checkout'
in 0.1 seconds automatically...
----

به یاد داشته باشید که این "0.1 ثانیه" است.
          `help.autocorrect` در واقع یک عدد صحیح است که نمایانگر دهم‌های ثانیه است.
          بنابراین اگر آن را به 50 تنظیم کنید، گیت به شما 5 ثانیه زمان می‌دهد تا قبل از اجرای دستور اصلاح شده، نظر خود
          را تغییر دهید.

==== رنگ‌ها در گیت

(((color)))
گیت به طور کامل از خروجی رنگی ترمینال پشتیبانی می‌کند، که به طور قابل توجهی در تجزیه بصری خروجی دستورات به سرعت
        و به آسانی کمک می‌کند.
        تعدادی از گزینه‌ها می‌توانند به شما کمک کنند تا رنگ‌آمیزی را به سلیقه خود تنظیم کنید.

===== `color.ui`

گیت به طور خودکار بیشتر خروجی‌های خود را رنگ‌آمیزی می‌کند، اما یک سوئیچ اصلی وجود دارد اگر این رفتار را
          نپسندید.
          برای خاموش کردن تمام خروجی رنگی ترمینال گیت، این کار را انجام دهید:

[source,console]
----
$ git config --global color.ui false
----

تنظیم پیش‌فرض `auto` است، که خروجی را زمانی که به طور مستقیم به یک ترمینال می‌رود رنگ‌آمیزی
          می‌کند، اما کدهای کنترل رنگ را زمانی که خروجی به یک لوله یا فایل هدایت می‌شود، حذف می‌کند.

شما همچنین می‌توانید آن را به `always` تنظیم کنید تا تفاوت بین ترمینال‌ها و لوله‌ها را نادیده
          بگیرد.
          شما به ندرت این کار را خواهید کرد؛ در بیشتر سناریوها، اگر می‌خواهید کدهای رنگی در خروجی هدایت شده خود داشته
          باشید، می‌توانید به جای آن یک پرچم `--color` به دستور گیت بدهید تا مجبور به استفاده از کدهای رنگی
          شود.
          تنظیم پیش‌فرض تقریباً همیشه چیزی است که شما می‌خواهید.

===== `color.*`

اگر می‌خواهید دقیق‌تر در مورد اینکه کدام دستورات رنگی هستند و چگونه، گیت تنظیمات رنگی خاصی برای افعال ارائه
          می‌دهد.
          هر یک از این‌ها می‌تواند به `true`، `false` یا `always` تنظیم شود:

  color.branch
  color.diff
  color.interactive
  color.status

علاوه بر این، هر یک از این‌ها دارای زیرتنظیماتی است که می‌توانید برای تنظیم رنگ‌های خاص برای بخش‌های خروجی
          استفاده کنید، اگر بخواهید هر رنگ را بازنویسی کنید.
          به عنوان مثال، برای تنظیم اطلاعات متا در خروجی diff خود به رنگ پیش‌زمینه آبی، پس‌زمینه سیاه و متن بولد،
          می‌توانید این دستور را اجرا کنید:

[source,console]
----
$ git config --global color.diff.meta "blue black bold"
----

شما می‌توانید رنگ را به هر یک از مقادیر زیر تنظیم کنید: `normal`، `black`،
          `red`، `green`، `yellow`، `blue`، `magenta`،
          `cyan`، یا `white`.
          اگر می‌خواهید ویژگی‌ای مانند بولد در مثال قبلی داشته باشید، می‌توانید از `bold`، `dim`،
          `ul` (زیرخط)، `blink` و `reverse` (معکوس کردن پیش‌زمینه و پس‌زمینه) انتخاب
          کنید.

[[_external_merge_tools]]
==== ابزارهای ادغام و تفاوت خارجی

(((mergetool)))(((difftool)))
اگرچه گیت یک پیاده‌سازی داخلی از diff دارد، که ما در این کتاب نشان داده‌ایم، می‌توانید به جای آن یک ابزار خارجی
        تنظیم کنید.
        شما همچنین می‌توانید یک ابزار گرافیکی برای حل تعارضات ادغام تنظیم کنید به جای اینکه مجبور باشید تعارضات را به
        صورت دستی حل کنید.
        ما تنظیم ابزار ادغام بصری Perforce (P4Merge) را برای انجام تفاوت‌ها و حل ادغام‌ها نشان خواهیم داد، زیرا این یک
        ابزار گرافیکی خوب و رایگان است.

اگر می‌خواهید این را امتحان کنید، P4Merge در تمام پلتفرم‌های اصلی کار می‌کند، بنابراین باید بتوانید این کار را
        انجام دهید.
        ما از نام‌های مسیر در مثال‌ها استفاده خواهیم کرد که در سیستم‌های macOS و Linux کار می‌کنند؛ برای ویندوز، باید
        `/usr/local/bin` را به یک مسیر اجرایی در محیط خود تغییر دهید.

برای شروع، https://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools[P4Merge
        را از Perforce دانلود کنید].
        سپس، شما اسکریپت‌های wrapper خارجی را برای اجرای دستورات خود تنظیم خواهید کرد.
        ما از مسیر macOS برای اجرایی استفاده خواهیم کرد؛ در سیستم‌های دیگر، این جایی خواهد بود که باینری
        `p4merge` شما نصب شده است.
        یک اسکریپت wrapper ادغام به نام `extMerge` تنظیم کنید که باینری شما را با تمام آرگومان‌های ارائه شده
        فراخوانی کند:

[source,console]
----
$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/p4merge.app/Contents/MacOS/p4merge $*
----

wrapper diff بررسی می‌کند که آیا هفت آرگومان ارائه شده است و دو تا از آن‌ها را به اسکریپت ادغام شما منتقل
        می‌کند.
        به طور پیش‌فرض، گیت آرگومان‌های زیر را به برنامه diff منتقل می‌کند:

[source]
----
path old-file old-hex old-mode new-file new-hex new-mode
----

زیرا شما فقط می‌خواهید آرگومان‌های `old-file` و `new-file` را داشته باشید، از اسکریپت
        wrapper برای انتقال آن‌هایی که نیاز دارید استفاده می‌کنید.

[source,console]
----
$ cat /usr/local/bin/extDiff
#!/bin/sh
[ $# -eq 7 ] && /usr/local/bin/extMerge "$2" "$5"
----

شما همچنین باید مطمئن شوید که این ابزارها قابل اجرا هستند:

[source,console]
----
$ sudo chmod +x /usr/local/bin/extMerge
$ sudo chmod +x /usr/local/bin/extDiff
----

اکنون می‌توانید فایل پیکربندی خود را برای استفاده از ابزارهای سفارشی ادغام و تفاوت خود تنظیم کنید.
        این نیاز به تعدادی تنظیمات سفارشی دارد: `merge.tool` برای گفتن به گیت که از چه استراتژی استفاده کند،
        `mergetool.<tool>.cmd` برای مشخص کردن نحوه اجرای دستور، `mergetool.<tool>.trustExitCode`
        برای گفتن به گیت که آیا کد خروج آن برنامه نشان‌دهنده یک ادغام موفق است یا خیر، و `diff.external` برای
        گفتن به گیت که چه دستوری را برای تفاوت‌ها اجرا کند.
        بنابراین، می‌توانید چهار دستور پیکربندی را اجرا کنید

[source,console]
----
$ git config --global merge.tool extMerge
$ git config --global mergetool.extMerge.cmd \
  'extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"'
$ git config --global mergetool.extMerge.trustExitCode false
$ git config --global diff.external extDiff
----
یا می‌توانید فایل `~/.gitconfig` خود را ویرایش کنید تا این خطوط را اضافه کنید:

[source,ini]
----
[merge]
  tool = extMerge
[mergetool "extMerge"]
  cmd = extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"
  trustExitCode = false
[diff]
  external = extDiff
----

پس از تنظیم همه این‌ها، اگر دستورات diff مانند این را اجرا کنید:

[source,console]
----
$ git diff 32d1776b1^ 32d1776b1
----

به جای دریافت خروجی diff در خط فرمان، گیت P4Merge را راه‌اندازی می‌کند که چیزی شبیه به این خواهد بود:

.P4Merge.
image::images/p4merge.png[P4Merge.]

اگر سعی کنید دو شاخه را ادغام کنید و سپس تعارضات ادغام داشته باشید، می‌توانید دستور `git mergetool`
        را اجرا کنید؛ این ابزار P4Merge را برای حل تعارضات از طریق آن ابزار GUI راه‌اندازی می‌کند.

نکته خوب در مورد این تنظیمات wrapper این است که می‌توانید ابزارهای تفاوت و ادغام خود را به راحتی تغییر دهید.
        به عنوان مثال، برای تغییر ابزارهای `extDiff` و `extMerge` به KDiff3، تنها کاری که باید
        انجام دهید ویرایش فایل `extMerge` است:

[source,console]
----
$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*
----

اکنون، گیت از ابزار KDiff3 برای مشاهده تفاوت‌ها و حل تعارضات ادغام استفاده خواهد کرد.

گیت به طور پیش‌فرض برای استفاده از تعدادی از ابزارهای دیگر حل تعارضات ادغام بدون نیاز به تنظیم پیکربندی cmd
        آماده است.
        برای دیدن فهرستی از ابزارهایی که پشتیبانی می‌کند، این کار را امتحان کنید:

[source,console]
----
$ git mergetool --tool-help
'git mergetool --tool=<tool>' ممکن است به یکی از موارد زیر تنظیم شود:
        emerge
        gvimdiff
        gvimdiff2
        opendiff
        p4merge
        vimdiff
        vimdiff2

ابزارهای زیر معتبر هستند، اما در حال حاضر در دسترس نیستند:
        araxis
        bc3
        codecompare
        deltawalker
        diffmerge
        diffuse
        ecmerge
        kdiff3
        meld
        tkdiff
        tortoisemerge
        xxdiff

برخی از ابزارهای ذکر شده در بالا فقط در یک محیط دارای پنجره کار می‌کنند. اگر در یک جلسه فقط ترمینال اجرا شوند، شکست خواهند خورد.
----

اگر به استفاده از KDiff3 برای تفاوت‌ها علاقه‌مند نیستید، بلکه فقط می‌خواهید از آن برای حل ادغام استفاده کنید و
        دستور kdiff3 در مسیر شما قرار دارد، می‌توانید این دستور را اجرا کنید:

[source,console]
----
$ git config --global merge.tool kdiff3
----

اگر این کار را به جای تنظیم فایل‌های `extMerge` و `extDiff` انجام دهید، گیت از KDiff3
        برای حل ادغام و از ابزار diff عادی گیت برای تفاوت‌ها استفاده خواهد کرد.

==== فرمت‌بندی و فاصله‌گذاری

(((whitespace)))
مسائل فرمت‌بندی و فاصله‌گذاری برخی از مشکلات آزاردهنده و ظریف هستند که بسیاری از توسعه‌دهندگان هنگام همکاری با
        آن‌ها مواجه می‌شوند، به ویژه در کارهای چندپلتفرمی.
        بسیار آسان است که وصله‌ها یا سایر کارهای مشترک تغییرات ظریف فاصله‌گذاری را معرفی کنند زیرا ویرایشگرها به طور
        خاموش آن‌ها را وارد می‌کنند، و اگر فایل‌های شما هرگز با یک سیستم ویندوزی تماس پیدا کنند، ممکن است انتهای خط
        آن‌ها جایگزین شود.
        گیت چند گزینه پیکربندی برای کمک به این مسائل دارد.

===== `core.autocrlf`

(((crlf)))(((line endings)))
اگر شما در ویندوز برنامه‌نویسی می‌کنید و با افرادی که این کار را نمی‌کنند (یا برعکس) کار می‌کنید، احتمالاً در
          یک نقطه با مسائل انتهای خط مواجه خواهید شد.
          این به این دلیل است که ویندوز از هر دو کاراکتر بازگشت به کاراکتر و کاراکتر خط جدید برای انتهای خط در فایل‌های
          خود استفاده می‌کند، در حالی که سیستم‌های macOS و Linux فقط از کاراکتر خط جدید استفاده می‌کنند.
          این یک واقعیت ظریف اما فوق‌العاده آزاردهنده در کارهای چندپلتفرمی است؛ بسیاری از ویرایشگرها در ویندوز به طور
          خاموش انتهای خط‌های LF موجود را با CRLF جایگزین می‌کنند، یا هر دو کاراکتر انتهای خط را زمانی که کاربر کلید
          Enter را فشار می‌دهد، وارد می‌کنند.

گیت می‌تواند این را با تبدیل خودکار انتهای خط CRLF به LF هنگام افزودن یک فایل به ایندکس و بالعکس هنگام چک‌اوت
          کد به سیستم فایل شما مدیریت کند.
          می‌توانید این قابلیت را با تنظیم `core.autocrlf` فعال کنید.
          اگر در یک ماشین ویندوز هستید، آن را به `true` تنظیم کنید -- این انتهای LF را به CRLF تبدیل می‌کند
          زمانی که کد را چک‌اوت می‌کنید:

[source,console]
----
$ git config --global core.autocrlf true
----

اگر در یک سیستم Linux یا macOS هستید که از انتهای LF استفاده می‌کند، پس نمی‌خواهید گیت به طور خودکار آن‌ها را
          هنگام چک‌اوت فایل‌ها تبدیل کند؛ با این حال، اگر فایلی با انتهای CRLF به طور تصادفی معرفی شود، ممکن است بخواهید
          گیت آن را اصلاح کند.
          می‌توانید به گیت بگویید که CRLF را به LF در کامیت تبدیل کند اما نه بالعکس با تنظیم `core.autocrlf`
          به input:

[source,console]
----
$ git config --global core.autocrlf input
----

این تنظیم باید به شما اجازه دهد که انتهای CRLF را در چک‌اوت‌های ویندوز داشته باشید، اما انتهای LF را در
          سیستم‌های macOS و Linux و در مخزن داشته باشید.

اگر شما یک برنامه‌نویس ویندوز هستید که پروژه‌ای فقط برای ویندوز انجام می‌دهید، می‌توانید این قابلیت را خاموش
          کنید و بازگشت‌های کاراکتر را در مخزن با تنظیم مقدار پیکربندی به `false` ثبت کنید:

[source,console]
----
$ git config --global core.autocrlf false
----

===== `core.whitespace`

گیت به طور پیش‌فرض برای شناسایی و اصلاح برخی از مسائل فاصله‌گذاری تنظیم شده است.
          می‌تواند به دنبال شش مشکل اصلی فاصله‌گذاری باشد -- سه مورد به طور پیش‌فرض فعال هستند و می‌توانند خاموش شوند، و
          سه مورد به طور پیش‌فرض غیرفعال هستند اما می‌توانند فعال شوند.

سه موردی که به طور پیش‌فرض فعال هستند `blank-at-eol` است، که به دنبال فضاها در انتهای یک خط
          می‌گردد؛ `blank-at-eof`، که خطوط خالی در انتهای یک فایل را شناسایی می‌کند؛ و
          `space-before-tab`، که به دنبال فضاها قبل از تب‌ها در ابتدای یک خط می‌گردد.

سه موردی که به طور پیش‌فرض غیرفعال هستند اما می‌توانند فعال شوند `indent-with-non-tab` است، که به
          دنبال خطوطی می‌گردد که با فضاها به جای تب‌ها شروع می‌شوند (و توسط گزینه `tabwidth` کنترل می‌شود)؛
          `tab-in-indent`، که به دنبال تب‌ها در بخش فاصله‌گذاری یک خط می‌گردد؛ و `cr-at-eol`، که
          به گیت می‌گوید که بازگشت‌های کاراکتر در انتهای خطوط اشکالی ندارد.

می‌توانید به گیت بگویید که کدام یک از این‌ها را می‌خواهید با تنظیم `core.whitespace` به مقادیر
          مورد نظر خود روشن یا خاموش کنید، که با کاما جدا شده‌اند.
          می‌توانید یک گزینه را با پیشوند `-` در جلوی نام آن غیرفعال کنید، یا با حذف آن از رشته تنظیم به ارزش
          پیش‌فرض برگردید.
          به عنوان مثال، اگر می‌خواهید همه به جز `space-before-tab` تنظیم شوند، می‌توانید این کار را انجام
          دهید (با `trailing-space` که به عنوان یک کوتاه‌نویس برای پوشش هر دو `blank-at-eol` و
          `blank-at-eof` است):

[source,console]
----
$ git config --global core.whitespace \
    trailing-space,-space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol
----

یا می‌توانید فقط قسمت سفارشی‌سازی را مشخص کنید:

[source,console]
----
$ git config --global core.whitespace \
    -space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol
----

گیت این مسائل را زمانی که دستور `git diff` را اجرا می‌کنید شناسایی می‌کند و سعی می‌کند آن‌ها را
          رنگ‌آمیزی کند تا بتوانید قبل از کامیت آن‌ها را اصلاح کنید.
          همچنین از این مقادیر برای کمک به شما هنگام اعمال وصله‌ها با `git apply` استفاده خواهد کرد.
          هنگامی که وصله‌ها را اعمال می‌کنید، می‌توانید از گیت بخواهید که اگر وصله‌هایی با مسائل فاصله‌گذاری مشخص شده را
          اعمال می‌کند، به شما هشدار دهد:

[source,console]
----
$ git apply --whitespace=warn <patch>
----

یا می‌توانید از گیت بخواهید که قبل از اعمال وصله، سعی کند مشکل را به طور خودکار اصلاح کند:

[source,console]
----
$ git apply --whitespace=fix <patch>
----

این گزینه‌ها همچنین به دستور `git rebase` اعمال می‌شوند.
          اگر شما مسائل فاصله‌گذاری را کامیت کرده‌اید اما هنوز به بالا فشار نداده‌اید، می‌توانید دستور `git rebase
            --whitespace=fix` را اجرا کنید تا گیت به طور خودکار مسائل فاصله‌گذاری را در حین بازنویسی وصله‌ها اصلاح
          کند.

==== پیکربندی سرور

گزینه‌های پیکربندی برای سمت سرور گیت به مراتب کمتر از آنچه که در سمت کلاینت وجود دارد، هستند، اما چند گزینه
        جالب وجود دارد که ممکن است بخواهید به آن‌ها توجه کنید.

===== `receive.fsckObjects`

گیت قادر است اطمینان حاصل کند که هر شیء دریافتی در حین یک فشار هنوز با checksum SHA-1 خود مطابقت دارد و به
          اشیاء معتبر اشاره می‌کند.
          با این حال، به طور پیش‌فرض این کار را انجام نمی‌دهد؛ این یک عملیات نسبتاً پرهزینه است و ممکن است عملیات را کند
          کند، به ویژه در مخازن یا فشارهای بزرگ.
          اگر می‌خواهید گیت در هر فشار، سازگاری اشیاء را بررسی کند، می‌توانید با تنظیم `receive.fsckObjects`
          به true این کار را مجبور کنید:

[source,console]
----
$ git config --system receive.fsckObjects true
----

اکنون، گیت قبل از پذیرش هر فشار، یکپارچگی مخزن شما را بررسی می‌کند تا مطمئن شود که مشتریان معیوب (یا مخرب)
          داده‌های خراب را معرفی نمی‌کنند.

===== `receive.denyNonFastForwards`

اگر شما کامیت‌هایی را که قبلاً فشار داده‌اید بازنویسی کنید و سپس سعی کنید دوباره فشار دهید، یا به طور دیگر
          سعی کنید یک کامیت را به یک شاخه از راه دور فشار دهید که شامل کامیتی نیست که شاخه از راه دور در حال حاضر به آن
          اشاره می‌کند، شما رد خواهید شد.
          این معمولاً سیاست خوبی است؛ اما در مورد بازنویسی، ممکن است تشخیص دهید که می‌دانید چه می‌کنید و می‌توانید با
          پرچم `-f` به دستور فشار خود، شاخه از راه دور را به‌روزرسانی کنید.

برای اینکه به گیت بگویید که از پذیرش فشارهای اجباری امتناع کند، `receive.denyNonFastForwards` را
          تنظیم کنید:

[source,console]
----
$ git config --system receive.denyNonFastForwards true
----

روش دیگر برای انجام این کار از طریق هوک‌های دریافت سمت سرور است، که در ادامه به آن خواهیم پرداخت.
          این رویکرد به شما اجازه می‌دهد کارهای پیچیده‌تری مانند رد کردن غیرپیشرفته‌ها برای یک زیرمجموعه خاص از کاربران
          را انجام دهید.

===== `receive.denyDeletes`

یکی از راه‌حل‌های دور زدن سیاست `denyNonFastForwards` این است که کاربر شاخه را حذف کند و سپس آن را
          با مرجع جدید فشار دهد.
          برای جلوگیری از این کار، `receive.denyDeletes` را به true تنظیم کنید:

[source,console]
----
$ git config --system receive.denyDeletes true
----

این هر گونه حذف شاخه‌ها یا برچسب‌ها را رد می‌کند -- هیچ کاربری نمی‌تواند این کار را انجام دهد.
          برای حذف شاخه‌های از راه دور، باید فایل‌های ref را به صورت دستی از سرور حذف کنید.
          همچنین روش‌های جالب‌تری برای انجام این کار به صورت کاربر به کاربر از طریق ACLها وجود دارد، همانطور که در <<_an_example_git_enforced_policy#_an_example_git_enforced_policy>>
          خواهید آموخت.
