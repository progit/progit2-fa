[[_maintaining_gh_project]]
=== Maintaining a Project (نگهداری یک پروژه)

حالا که با مشارکت در یک پروژه راحت شدیم، بیایید نگاهی به سمت دیگر ماجرا بیندازیم: ایجاد، نگهداری و مدیریت پروژه‌ی خودتان.

==== Creating a New Repository (ساخت یک ریپازیتوری)

بیایید یک مخزن جدید بسازیم تا کد پروژه‌مان را با دیگران به اشتراک بگذاریم.
برای شروع، روی دکمه‌ی «New repository» در سمت راست داشبورد کلیک کنید، یا از دکمه‌ی + که کنار نام کاربری‌تان در نوار ابزار بالاست استفاده کنید، همان‌طور که در <<_new_repo_dropdown>> مشاهده می‌شود.

.The ``Your repositories'' area.
image::images/newrepo.png[The ``Your repositories'' area.]

[[_new_repo_dropdown]]
.The ``New repository'' dropdown.
image::images/new-repo.png[The ``new repository'' dropdown.]

این شما را به فرم «new repository» هدایت می‌کند:

.The ``new repository'' form.
image::images/newrepoform.png[The ``new repository'' form.]

در اینجا تنها کاری که باید انجام دهید، وارد کردن نام پروژه است؛ بقیه فیلدها کاملاً اختیاری هستند.
فعلاً فقط روی دکمه «Create Repository» کلیک کنید، و به همین راحتی — یک مخزن جدید در گیت‌هاب با نام `<user>/<project_name>` ساخته می‌شود.

از آنجایی که هنوز کدی در این مخزن وجود ندارد، گیت‌هاب راهنمایی‌هایی برای ایجاد یک مخزن گیت جدید یا اتصال به یک پروژه گیت موجود به شما نشان می‌دهد.
ما اینجا زیاد وارد جزئیات نمی‌شویم؛ اگر نیاز به یادآوری دارید، به <<ch02-git-basics-chapter#ch02-git-basics-chapter>> مراجعه کنید.

حالا که پروژه‌ی شما روی گیت‌هاب میزبانی می‌شود، می‌توانید آدرس آن را به هر کسی که می‌خواهید برای اشتراک‌گذاری پروژه بدهید.
هر پروژه در گیت‌هاب از طریق HTTPS به آدرس `https://github.com/<user>/<project_name>` و از طریق SSH به آدرس `git@github.com:<user>/<project_name>` قابل دسترسی است.
گیت می‌تواند هم از این دو آدرس دریافت (fetch) و ارسال (push) انجام دهد، اما دسترسی بر اساس مجوزهای کاربری که متصل می‌شود کنترل می‌شود.

[NOTE]
====
معمولاً بهتر است برای پروژه‌های عمومی، آدرس مبتنی بر HTTPS را به اشتراک بگذارید، چون کاربران برای کلون کردن آن نیازی به داشتن حساب کاربری گیت‌هاب ندارند.
اگر آدرس SSH را بدهید، کاربران باید حساب کاربری گیت‌هاب داشته باشند و کلید SSH خود را بارگذاری کرده باشند تا به پروژه شما دسترسی پیدا کنند.
همچنین آدرس HTTPS دقیقاً همان آدرسی است که کاربران می‌توانند در مرورگر خود وارد کنند و پروژه را به صورت آنلاین مشاهده کنند.
====

==== Adding Collaborators (افزودن همکاران)

اگر با افراد دیگری کار می‌کنید و می‌خواهید به آن‌ها اجازه‌ی commit زدن بدهید، باید آن‌ها را به‌عنوان «collaborators» اضافه کنید.
اگر بن، جف و لوئیز حساب‌های کاربری گیت‌هاب بسازند و شما بخواهید دسترسی push به مخزن خود به آن‌ها بدهید، می‌توانید آن‌ها را به پروژه اضافه کنید.
این کار به آن‌ها دسترسی «push» می‌دهد، یعنی هم اجازه خواندن و هم نوشتن روی پروژه و مخزن گیت را خواهند داشت.

برای این کار، روی لینک «Settings» در پایین نوار کناری سمت راست کلیک کنید.

.The repository settings link.
image::images/reposettingslink.png[The repository settings link.]

سپس از منوی سمت چپ گزینه‌ی «Collaborators» را انتخاب کنید.
بعد، نام کاربری (username) مورد نظر را در کادر وارد کنید و روی «Add collaborator» کلیک کنید.
می‌توانید این کار را هر تعداد که بخواهید تکرار کنید تا به همه کسانی که می‌خواهید دسترسی بدهید.
اگر نیاز داشتید دسترسی کسی را لغو کنید، کافی است روی علامت «X» سمت راست ردیف آن فرد کلیک کنید.

.Repository collaborators.
image::images/collaborators.png[The repository collaborators box.]

==== Managing Pull Requests (مدیریت Pull Request ها)

حالا که یک پروژه با چند خط کد دارید و شاید چند همکار که دسترسی push دارند، بیایید ببینیم وقتی یک Pull Request دریافت می‌کنید، چه کاری باید انجام دهید.

Pull Requestها ممکن است از یک شاخه (branch) در یک fork از مخزن شما باشند، یا از یک شاخه‌ی دیگر در همان مخزن.
تفاوت اصلی این است که در fork معمولاً افراد نمی‌توانند روی شاخه‌ی شما push کنند و شما هم نمی‌توانید روی شاخه‌ی آن‌ها push کنید، اما در Pull Requestهای داخلی معمولاً هر دو طرف به شاخه دسترسی دارند.

برای این مثال‌ها، فرض کنیم شما با نام کاربری «tonychacon» هستید و یک پروژه‌ی جدید کد Arduino به نام «fade» ایجاد کرده‌اید.

[[_email_notifications]]
===== Email Notifications (اعلانات ایمیل)

شخصی تغییراتی در کد شما ایجاد می‌کند و یک Pull Request برایتان ارسال می‌کند.
شما باید ایمیلی دریافت کنید که درباره‌ی Pull Request جدید اطلاع‌رسانی می‌کند و این ایمیل باید چیزی شبیه به <<_email_pr>> باشد.

[[_email_pr]]
ایمیل اطلاع‌رسانی درباره‌ی یک Pull Request جدید.
image::images/maint-01-email.png[Pull Request email notification]

چند نکته مهم در این ایمیل وجود دارد:

    یک diffstat کوچک به شما نشان می‌دهد — یعنی فهرستی از فایل‌هایی که در Pull Request تغییر کرده‌اند و میزان تغییرات هر کدام.

    لینک مستقیمی به Pull Request روی گیت‌هاب دارد.

    چند آدرس URL هم به شما می‌دهد که می‌توانید از خط فرمان استفاده کنید.

اگر به خطی که می‌گوید git pull <url> patch-1 دقت کنید، این یک روش ساده برای ادغام (merge) یک شاخه‌ی راه دور (remote branch) است بدون اینکه نیاز باشد ریموت جدیدی اضافه کنید.
ما این موضوع را به‌صورت مختصر در <<ch05-distributed-git#_checking_out_remotes>> بررسی کردیم.
اگر بخواهید، می‌توانید ابتدا یک شاخه موضوعی (topic branch) بسازید و به آن سوییچ کنید، سپس این دستور را اجرا کنید تا تغییرات Pull Request را ادغام کنید.

آدرس‌های جالب دیگر، URLهای .diff و .patch هستند که همان‌طور که حدس می‌زنید، نسخه‌های unified diff و patch از Pull Request را فراهم می‌کنند.
از لحاظ فنی می‌توانید با چیزی شبیه به این هم کار ادغام Pull Request را انجام دهید:

[source,console]
----
$ curl https://github.com/tonychacon/fade/pull/1.patch | git am
----

===== Collaborating on the Pull Request (همکاری روی Pull Request)

همان‌طور که در <<ch06-github#ch06-github_flow>> توضیح دادیم، حالا می‌توانید با فردی که Pull Request را باز کرده وارد گفتگو شوید.
می‌توانید روی خطوط خاصی از کد نظر بگذارید، روی کامیت‌های کامل کامنت بگذارید یا درباره کل Pull Request صحبت کنید، و در تمام این موارد می‌توانید از Markdown مخصوص گیت‌هاب استفاده کنید.

هر بار که کسی روی Pull Request نظر بگذارد، شما ایمیل اطلاع‌رسانی دریافت خواهید کرد تا از فعالیت‌ها مطلع باشید.
هر ایمیل شامل لینکی به همان Pull Request است که فعالیت در آن انجام شده و همچنین می‌توانید مستقیماً از طریق پاسخ به همان ایمیل در همان رشته‌ی گفتگو نظر دهید.

.Responses to emails are included in the thread.
image::images/maint-03-email-resp.png[Email response]

وقتی کد به جایی رسید که از آن راضی هستید و می‌خواهید آن را ادغام کنید، می‌توانید کد را دانلود کرده و به صورت محلی ادغام کنید، یا با استفاده از دستور git pull <url> <branch> که قبلاً دیدیم، یا با اضافه کردن fork به‌عنوان یک ریموت و سپس fetch و merge کردن.

اگر ادغام ساده و بدون تعارض باشد، می‌توانید مستقیماً روی دکمه «Merge» در سایت گیت‌هاب کلیک کنید.
این عملیات یک ادغام «non-fast-forward» انجام می‌دهد و حتی اگر امکان fast-forward merge وجود داشته باشد، یک commit ادغام (merge commit) ایجاد می‌کند.
به این معنی که هر بار دکمه merge را بزنید، یک commit ادغام ساخته می‌شود.
همانطور که در <<_merge_button>> می‌بینید، گیت‌هاب تمام این اطلاعات را وقتی روی لینک راهنما کلیک می‌کنید، به شما نشان می‌دهد.

[[_merge_button]]
.Merge button and instructions for merging a Pull Request manually.
image::images/maint-02-merge.png[Merge button]

اگر تصمیم گرفتید که نمی‌خواهید ادغام کنید، می‌توانید به سادگی Pull Request را ببندید و فردی که آن را باز کرده است، از این موضوع مطلع خواهد شد.

[[_pr_refs]]
===== Pull Request Refs (رفرنس‌های Pull Request)

اگر با تعداد زیادی Pull Request سر و کار دارید و نمی‌خواهید برای هر بار گرفتن تغییرات، ریموت‌های زیادی اضافه کنید یا هر بار pull انجام دهید، یک ترفند جالب وجود دارد که گیت‌هاب به شما اجازه می‌دهد انجام دهید.
این یک ترفند پیشرفته‌تر است و جزئیات بیشتری درباره آن در <<ch10-git-internals#_refspec>> خواهیم گفت، اما می‌تواند بسیار کاربردی باشد.

در واقع گیت‌هاب شاخه‌های Pull Request را به صورت شاخه‌های شبه‌مستقل (pseudo-branches) روی سرور نمایش می‌دهد.
به طور پیش‌فرض این شاخه‌ها هنگام کلون کردن دریافت نمی‌شوند، اما به شکلی مخفی وجود دارند و شما می‌توانید به راحتی به آن‌ها دسترسی پیدا کنید.

برای نشان دادن این موضوع، از یک دستور سطح پایین (که اغلب به آن دستور «plumbing» گفته می‌شود و در <<ch10-git-internals#_plumbing_porcelain>> بیشتر درباره‌اش می‌خوانیم) به نام ls-remote استفاده می‌کنیم.
این دستور معمولاً در عملیات روزمره گیت استفاده نمی‌شود، اما برای نمایش رفرنس‌های موجود روی سرور کاربردی است.

اگر این دستور را روی مخزن «blink» که قبلاً استفاده کردیم اجرا کنیم، فهرستی از تمام شاخه‌ها، تگ‌ها و سایر رفرنس‌ها در مخزن دریافت خواهیم کرد.

[source,console]
----
$ git ls-remote https://github.com/schacon/blink
10d539600d86723087810ec636870a504f4fee4d	HEAD
10d539600d86723087810ec636870a504f4fee4d	refs/heads/master
6a83107c62950be9453aac297bb0193fd743cd6e	refs/pull/1/head
afe83c2d1a70674c9505cc1d8b7d380d5e076ed3	refs/pull/1/merge
3c8d735ee16296c242be7a9742ebfbc2665adec1	refs/pull/2/head
15c9f4f80973a2758462ab2066b6ad9fe8dcf03d	refs/pull/2/merge
a5a7751a33b7e86c5e9bb07b26001bb17d775d1a	refs/pull/4/head
31a45fc257e8433c8d8804e3e848cf61c9d3166c	refs/pull/4/merge
----

البته، اگر در مخزن خودتان باشید و دستور `git ls-remote origin` یا هر ریموتی که می‌خواهید را اجرا کنید، چیزی مشابه این را مشاهده خواهید کرد.

اگر مخزن روی گیت‌هاب باشد و Pull Request هایی باز شده باشد، رفرنس‌هایی را خواهید دید که با refs/pull/ شروع می‌شوند.
این‌ها در واقع شاخه‌هایی هستند، اما چون زیر شاخه refs/heads/ نیستند، به‌طور معمول هنگام کلون یا fetch گرفتن دریافت نمی‌شوند — فرایند fetch معمولاً آن‌ها را نادیده می‌گیرد.

برای هر Pull Request دو رفرنس وجود دارد — رفرنس‌ای که با /head ختم می‌شود دقیقاً به همان کامیتی اشاره دارد که آخرین کامیت شاخه‌ی Pull Request است.
پس اگر کسی در مخزن ما یک Pull Request باز کند و شاخه‌شان bug-fix نام داشته باشد و به کامیت a5a775 اشاره کند، در مخزن ما شاخه‌ای به نام bug-fix وجود ندارد (چون آن شاخه در fork آن‌هاست)، اما یک رفرنس pull/<شماره-pr>/head خواهیم داشت که به a5a775 اشاره می‌کند.
این یعنی می‌توانیم خیلی راحت همه شاخه‌های Pull Request را یکجا دانلود کنیم بدون اینکه لازم باشد ریموت‌های زیادی اضافه کنیم.

حالا می‌توانید به‌صورت مستقیم این رفرنس‌ها را fetch کنید.

[source,console]
----
$ git fetch origin refs/pull/958/head
From https://github.com/libgit2/libgit2
 * branch            refs/pull/958/head -> FETCH_HEAD
----

این دستور به گیت می‌گوید: «به ریموت origin وصل شو و رفرنس به نام refs/pull/958/head را دانلود کن.»
گیت هم به راحتی این کار را انجام می‌دهد و همه چیز لازم برای ساختن آن رفرنس را دانلود می‌کند و اشاره‌گری به کامیت مورد نظر را در .git/FETCH_HEAD قرار می‌دهد.
بعد از آن می‌توانید با دستور git merge FETCH_HEAD آن تغییرات را در شاخه‌ای که می‌خواهید تست کنید، ادغام کنید، اما پیام کامیت ادغام ممکن است کمی عجیب به نظر برسد.
همچنین اگر تعداد زیادی Pull Request برای بررسی دارید، این کار می‌تواند خسته‌کننده شود.

یک راه دیگر هم وجود دارد تا همه Pull Requestها را یکجا fetch کنید و هر بار که به ریموت وصل می‌شوید، آن‌ها را به‌روز نگه دارید.
فایل .git/config را در ویرایشگر مورد علاقه‌تان باز کنید و به دنبال بخش مربوط به ریموت origin بگردید.
این بخش باید چیزی شبیه به این باشد:

[source,ini]
----
[remote "origin"]
    url = https://github.com/libgit2/libgit2
    fetch = +refs/heads/*:refs/remotes/origin/*
----

خطی که با `fetch =` شروع می‌شود، یک «refspec» است.
این یک روش برای نگاشت نام‌ها در ریموت به نام‌های موجود در دایرکتوری محلی .git شماست.
این refspec خاص به گیت می‌گوید: «مواردی که در ریموت زیر refs/heads هستند باید در مخزن محلی من زیر refs/remotes/origin قرار بگیرند.»
شما می‌توانید این بخش را ویرایش کنید و یک refspec دیگر اضافه کنید:

[source,ini]
----
[remote "origin"]
    url = https://github.com/libgit2/libgit2.git
    fetch = +refs/heads/*:refs/remotes/origin/*
    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
----

خط آخر به گیت می‌گوید: «تمام رفرنس‌هایی که شبیه refs/pull/123/head هستند، باید به صورت محلی زیر refs/remotes/origin/pr/123 ذخیره شوند.»
حالا اگر این فایل را ذخیره کنید و دستور `git fetch` را اجرا کنید:

[source,console]
----
$ git fetch
# …
 * [new ref]         refs/pull/1/head -> origin/pr/1
 * [new ref]         refs/pull/2/head -> origin/pr/2
 * [new ref]         refs/pull/4/head -> origin/pr/4
# …
----

حالا همه‌ی Pull Requestهای ریموت به صورت محلی با رفرنس‌هایی نمایش داده می‌شوند که مثل شاخه‌های دنبال‌کننده (tracking branches) عمل می‌کنند؛ این رفرنس‌ها فقط قابل‌خواندن هستند و هر بار که fetch می‌کنید به‌روزرسانی می‌شوند.
این کار تست کردن کدهای یک Pull Request به صورت محلی را بسیار آسان می‌کند:

[source,console]
----
$ git checkout pr/2
Checking out files: 100% (3769/3769), done.
Branch pr/2 set up to track remote branch pr/2 from origin.
Switched to a new branch 'pr/2'
----

دقیق‌بین‌ها متوجه «head» در انتهای قسمت ریموت رفرنس‌اسپک خواهند شد.
در گیت‌هاب همچنین رفرنس refs/pull/#/merge وجود دارد که نشان‌دهنده‌ی کامیتی است که در صورت زدن دکمه «merge» روی سایت، ایجاد خواهد شد.
این رفرنس به شما امکان می‌دهد قبل از کلیک روی دکمه، عملیات ادغام را تست کنید.

===== Pull Requests on Pull Requests (Pull Requests روی Pull Requests)

شما فقط نمی‌توانید Pull Requestهایی باز کنید که به شاخه‌ی اصلی یا master اشاره دارند، بلکه می‌توانید Pull Request را به هر شاخه‌ای در شبکه هدف بگیرید.
در واقع، حتی می‌توانید یک Pull Request را هدف یک Pull Request دیگر قرار دهید.

اگر یک Pull Request را دیدید که در مسیر درستی حرکت می‌کند و ایده‌ای برای تغییر دارید که به آن وابسته است، یا مطمئن نیستید که آن تغییر ایده خوبی باشد، یا اینکه به شاخه‌ی هدف دسترسی push ندارید، می‌توانید مستقیماً یک Pull Request به آن باز کنید.

وقتی می‌خواهید یک Pull Request باز کنید، بالای صفحه جعبه‌ای وجود دارد که مشخص می‌کند کدام شاخه را می‌خواهید تغییرات را روی آن اعمال کنید (pull to) و از کدام شاخه می‌خواهید تغییرات را بگیرید (pull from).
اگر روی دکمه «Edit» در سمت راست آن جعبه کلیک کنید، می‌توانید نه تنها شاخه‌ها را تغییر دهید بلکه فورک (fork) مورد نظر را هم عوض کنید.

[[_pr_targets]]
.Manually change the Pull Request target fork and branch.
image::images/maint-04-target.png[PR targets]

اینجا به‌راحتی می‌توانید مشخص کنید که شاخه‌ی جدیدتان را به یک Pull Request دیگر یا به یک فورک (fork) دیگر از پروژه ادغام کنید.

==== Mentions and Notifications (منشن‌ها و اعلان‌ها)

گیت‌هاب یک سیستم اعلان خیلی خوب دارد که وقتی سوالی دارید یا به بازخورد از افراد یا تیم‌های خاص نیاز دارید، بسیار کاربردی است.

در هر کامنتی می‌توانید با نوشتن کاراکتر @ شروع کنید و گیت‌هاب به‌صورت خودکار نام و نام‌کاربری کسانی را که همکار یا مشارکت‌کننده در پروژه هستند، به شما پیشنهاد می‌دهد.

.Start typing @ to mention someone.
image::images/maint-05-mentions.png[Mentions]

می‌توانید کاربری را هم منشن کنید که در آن لیست کشویی نیست، اما معمولاً قابلیت تکمیل خودکار این کار را سریع‌تر می‌کند.

وقتی کامنتی با منشن یک کاربر ارسال کنید، آن کاربر مطلع خواهد شد.
این یعنی منشن کردن یک روش بسیار موثر برای جلب توجه افراد به مکالمات است، به جای اینکه آن‌ها مجبور باشند مدام چک کنند.
در Pull Requestهای گیت‌هاب، معمولاً افراد دیگر اعضای تیم یا شرکت خود را برای بررسی یک Issue یا Pull Request به گفتگو دعوت می‌کنند.

اگر کسی در یک Pull Request یا Issue منشن شود، به آن موضوع «اشتراک» (subscribe) داده می‌شود و هر بار که فعالیتی روی آن انجام شود، اعلان دریافت خواهد کرد.
شما هم اگر خودتان آن را باز کرده باشید، یا در حال دنبال کردن (watch) مخزن باشید، یا روی چیزی نظر گذاشته باشید، به‌طور خودکار عضو آن موضوع خواهید شد.
اگر دیگر نمی‌خواهید اعلان دریافت کنید، یک دکمه «Unsubscribe» روی صفحه وجود دارد که با کلیک روی آن می‌توانید دریافت اعلان‌ها را متوقف کنید.

.Unsubscribe from an Issue or Pull Request.
image::images/maint-06-unsubscribe.png[Unsubscribe]

===== The Notifications Page (صفحه اعلان‌ها)

وقتی اینجا درباره «اعلان‌ها» در گیت‌هاب صحبت می‌کنیم، منظورمان روشی خاص است که گیت‌هاب برای اطلاع‌رسانی به شما هنگام وقوع رویدادها استفاده می‌کند و چند روش مختلف برای تنظیم آن وجود دارد.
اگر به تب «Notification center» در صفحه تنظیمات بروید، می‌توانید برخی از گزینه‌های موجود را مشاهده کنید.

.Notification center options.
image::images/maint-07-notifications.png[Notification center]

دو گزینه برای دریافت اعلان‌ها وجود دارد: «ایمیل» و «وب»؛
شما می‌توانید برای زمانی که خودتان در فعالیت‌ها مشارکت دارید و برای فعالیت‌های مخازنی که دنبال می‌کنید، هر کدام را به دلخواه انتخاب کنید، هیچ‌کدام را انتخاب نکنید، یا هر دو را فعال کنید.

====== Web Notifications (اعلان‌های وب)

اعلان‌های وب فقط روی خود گیت‌هاب وجود دارند و فقط از طریق گیت‌هاب قابل مشاهده‌اند.
اگر این گزینه را در تنظیمات خود فعال کرده باشید و برایتان اعلان جدیدی بیاید، یک نقطه آبی کوچک روی آیکون اعلان‌ها در بالای صفحه‌تان ظاهر می‌شود، همانطور که در <<_not_center>> می‌بینید.

[[_not_center]]
.Notification center.
image::images/maint-08-notifications-page.png[Notification center]

اگر روی آن کلیک کنید، فهرستی از تمام اعلان‌هایی که دریافت کرده‌اید را خواهید دید که بر اساس پروژه‌ها گروه‌بندی شده‌اند.
می‌توانید با کلیک روی نام یک پروژه در نوار کناری سمت چپ، فقط اعلان‌های همان پروژه را فیلتر کنید.
همچنین می‌توانید با کلیک روی آیکون تیک کنار هر اعلان، آن اعلان را تأیید (acknowledge) کنید، یا با کلیک روی تیک بالای گروه، همه اعلان‌های آن پروژه را تأیید نمایید.
در کنار هر تیک، دکمه‌ای به شکل «بی‌صدا» (mute) وجود دارد که با کلیک روی آن، دیگر اعلان‌های آن مورد برای شما ارسال نخواهد شد.

تمام این ابزارها برای مدیریت تعداد زیادی اعلان بسیار کاربردی هستند.
بسیاری از کاربران حرفه‌ای گیت‌هاب، اعلان‌های ایمیلی را به طور کامل غیرفعال می‌کنند و همه اعلان‌های خود را فقط از طریق همین صفحه مدیریت می‌کنند.

====== Email Notifications (اعلان‌های ایمیلی)

اعلان‌های ایمیلی، روش دیگری برای مدیریت اعلان‌ها در گیت‌هاب است.
اگر این گزینه را فعال کرده باشید، برای هر اعلان یک ایمیل دریافت خواهید کرد.
نمونه‌هایی از این ایمیل‌ها را در <<_email_notification>> و <<_email_pr>> دیدیم.
این ایمیل‌ها به صورت موضوع‌بندی شده (threaded) ارسال می‌شوند که اگر از ایمیل کلاینتی با قابلیت موضوع‌بندی استفاده کنید، کار را بسیار راحت می‌کند.

همچنین در هدر ایمیل‌هایی که گیت‌هاب برای شما ارسال می‌کند، مقدار زیادی داده متا (metadata) قرار دارد که می‌تواند برای ساخت فیلترها و قواعد سفارشی بسیار مفید باشد.

مثلاً اگر به هدر ایمیلی که به تونی در نمونه‌ی <<_email_pr>> ارسال شده نگاه کنیم، اطلاعات زیر را خواهیم دید:

[source,mbox]
----
To: tonychacon/fade <fade@noreply.github.com>
Message-ID: <tonychacon/fade/pull/1@github.com>
Subject: [fade] Wait longer to see the dimming effect better (#1)
X-GitHub-Recipient: tonychacon
List-ID: tonychacon/fade <fade.tonychacon.github.com>
List-Archive: https://github.com/tonychacon/fade
List-Post: <mailto:reply+i-4XXX@reply.github.com>
List-Unsubscribe: <mailto:unsub+i-XXX@reply.github.com>,...
X-GitHub-Recipient-Address: tchacon@example.com
----

چند نکته جالب درباره این موارد وجود دارد:

    اگر بخواهید ایمیل‌ها را برای این پروژه خاص یا حتی یک Pull Request مشخص برجسته کنید یا به پوشه یا آدرس دیگری هدایت کنید، اطلاعات موجود در فیلد Message-ID تمام داده‌های لازم را به صورت قالب <user>/<project>/<type>/<id> در اختیار شما می‌گذارد.
    به عنوان مثال اگر موضوع ایمیل مربوط به یک Issue بود، به جای pull در قسمت <type> عبارت issues می‌آمد.

    فیلدهای List-Post و List-Unsubscribe به این معنی هستند که اگر کلاینت ایمیل شما این فیلدها را پشتیبانی کند، می‌توانید به راحتی پاسخ ارسال کنید یا از دریافت اعلان‌های بیشتر (Unsubscribe) برای آن رشته (thread) منصرف شوید.
    این عملکرد معادل کلیک کردن روی دکمه «mute» در نسخه وب اعلان یا دکمه «Unsubscribe» در صفحه Issue یا Pull Request است.

    همچنین خوب است بدانید اگر هر دو نوع اعلان ایمیلی و وبی فعال باشند، وقتی ایمیل را در کلاینت خود خواندید (و اگر اجازه‌ی بارگذاری تصاویر در ایمیل داده باشید)، نسخه وبی اعلان هم به صورت خوانده شده علامت‌گذاری می‌شود.

==== Special Files (فایل های ویژه)

گیت‌هاب چند فایل خاص دارد که اگر در مخزن شما وجود داشته باشند، به طور خودکار آن‌ها را شناسایی و رفتار مخصوصی با آن‌ها انجام می‌دهد.
اگر مایلید، می‌توانم درباره این فایل‌های خاص و کاربردشان بیشتر توضیح بدهم.

==== README (ریدمی)

فایل اول، فایل `README` است که می‌تواند تقریباً در هر فرمتی باشد که گیت‌هاب به عنوان متن قابل نمایش شناسایی می‌کند.
مثلاً: README، README.md، README.asciidoc و غیره.

وقتی گیت‌هاب چنین فایلی را در مخزن شما ببیند، آن را در صفحه‌ی اصلی (landing page) پروژه به صورت زیبا و خوانا نمایش می‌دهد.

معمولاً تیم‌ها از این فایل برای جمع‌آوری اطلاعات مهم و اصلی پروژه استفاده می‌کنند، مخصوصاً برای افرادی که تازه با پروژه آشنا می‌شوند. این اطلاعات معمولاً شامل موارد زیر است:

    * هدف و کاربرد پروژه چیست؟

    * چطور پروژه را نصب و پیکربندی کنیم؟

    * نمونه‌ای از استفاده یا نحوه اجرای پروژه

    * مجوز (License) پروژه تحت چه شرایطی است

    * چطور می‌توان در پروژه مشارکت کرد (contributing)

از آنجا که گیت‌هاب این فایل را رندر می‌کند، شما می‌توانید تصاویر، لینک‌ها و قالب‌بندی Markdown یا هر فرمت پشتیبانی شده را در آن قرار دهید تا فهم و استفاده از پروژه برای دیگران آسان‌تر شود.

==== CONTRIBUTING (مشارکت)

فایل ویژه‌ی دیگری که گیت‌هاب آن را شناسایی می‌کند، فایل CONTRIBUTING است.
اگر فایلی با نام CONTRIBUTING و با هر پسوندی داشته باشید، گیت‌هاب هنگام باز کردن یک Pull Request توسط هر کسی، <<_contrib_file>> را نمایش خواهد داد.

[[_contrib_file]]
.Opening a Pull Request when a CONTRIBUTING file exists.
image::images/maint-09-contrib.png[Contributing notice]

ایده اینجا این است که می‌توانید موارد مشخصی را که می‌خواهید یا نمی‌خواهید در یک Pull Request به پروژه‌تان ارسال شود، تعیین کنید.
به این صورت، افراد ممکن است واقعاً دستورالعمل‌ها را قبل از باز کردن Pull Request بخوانند.

==== Project Administration (مدیریت پروژه)

به‌طور کلی، کارهای مدیریتی زیادی وجود ندارد که بتوانید روی یک پروژهٔ تکی انجام دهید، اما چند مورد هستند که ممکن است برایتان جالب باشند.

===== Changing the Default Branch (تغییر شاخهٔ پیش‌فرض)

اگر به‌جای شاخهٔ «master» از شاخهٔ دیگری به‌عنوان شاخهٔ پیش‌فرض استفاده می‌کنید—شاخه‌ای که می‌خواهید افراد Pull Request های خود را به آن بفرستند یا به‌صورت پیش‌فرض آن را ببینند—می‌توانید این تنظیم را در صفحهٔ تنظیمات مخزن خود، در بخش «Options»، تغییر دهید.

[[_default_branch]]
.Change the default branch for a project.
image::images/maint-10-default-branch.png[Default branch]

کافی‌ست شاخهٔ پیش‌فرض را از منوی کشویی تغییر دهید؛ از آن پس، این شاخه به‌عنوان شاخهٔ پیش‌فرض برای تمام عملیات‌های اصلی در نظر گرفته خواهد شد—از جمله شاخه‌ای که هنگام کلون کردن مخزن، به‌صورت پیش‌فرض انتخاب و بررسی (checkout) می‌شود.

===== Transferring a Project (انتقال پروژه)

اگر می‌خواهید پروژه‌ای را به کاربر یا سازمان دیگری در گیت‌هاب منتقل کنید، گزینه‌ای به نام «Transfer ownership» (انتقال مالکیت) در پایین همان تب «Options» در صفحه تنظیمات مخزن شما وجود دارد که این امکان را فراهم می‌کند.

[[_transfer_project]]
.Transfer a project to another GitHub user or Organization.
image::images/maint-11-transfer.png[Transfer]

این گزینه زمانی مفید است که می‌خواهید پروژه‌ای را رها کنید و فرد دیگری قصد دارد آن را ادامه دهد، یا زمانی که پروژه‌تان بزرگ‌تر شده و می‌خواهید آن را به یک سازمان منتقل کنید.

این کار نه‌تنها مخزن را همراه با تمام دنبال‌کنندگان (watchers) و ستاره‌ها (stars) به مکان جدید منتقل می‌کند، بلکه یک ریدایرکت (تغییر مسیر) از آدرس قبلی شما به محل جدید تنظیم می‌نماید.
این ریدایرکت فقط محدود به درخواست‌های وب نیست، بلکه شامل clone و fetch در گیت نیز می‌شود.